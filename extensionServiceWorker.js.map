{"version":3,"file":"extensionServiceWorker.js","mappings":"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","sources":["webpack://mytonwallet/webpack/runtime/chunk loaded","webpack://mytonwallet/./src/api/environment.ts","webpack://mytonwallet/./src/config.ts","webpack://mytonwallet/./src/util/createPostMessageInterface.ts","webpack://mytonwallet/./src/util/ledger/tab.ts","webpack://mytonwallet/./src/util/account.ts","webpack://mytonwallet/./src/api/storages/index.ts","webpack://mytonwallet/./src/api/common/utils.ts","webpack://mytonwallet/./src/api/common/backend.ts","webpack://mytonwallet/./src/api/common/addresses.ts","webpack://mytonwallet/./src/api/common/txCallbacks.ts","webpack://mytonwallet/./src/api/common/helpers.ts","webpack://mytonwallet/./src/api/common/accounts.ts","webpack://mytonwallet/./src/api/blockchains/ton/auth.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/tonapiio.ts","webpack://mytonwallet/./src/api/blockchains/ton/constants.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/index.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/tonweb.ts","webpack://mytonwallet/./src/api/blockchains/ton/wallet.ts","webpack://mytonwallet/./src/api/blockchains/ton/nfts.ts","webpack://mytonwallet/./src/api/types/misc.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/encryption.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/metadata.ts","webpack://mytonwallet/./src/api/blockchains/ton/util/tonCore.ts","webpack://mytonwallet/./src/util/dns.ts","webpack://mytonwallet/./src/api/blockchains/ton/address.ts","webpack://mytonwallet/./src/api/blockchains/ton/tokens.ts","webpack://mytonwallet/./src/api/blockchains/ton/transactions.ts","webpack://mytonwallet/./src/api/blockchains/ton/contracts/NominatorPool.ts","webpack://mytonwallet/./src/api/blockchains/ton/staking.ts","webpack://mytonwallet/./src/api/blockchains/ton/other.ts","webpack://mytonwallet/./src/api/blockchains/index.ts","webpack://mytonwallet/./src/api/errors.ts","webpack://mytonwallet/./src/api/common/dappPromises.ts","webpack://mytonwallet/./src/api/dappMethods/window.ts","webpack://mytonwallet/./src/api/dappMethods/index.ts","webpack://mytonwallet/./src/api/methods/dapps.ts","webpack://mytonwallet/./src/api/methods/extension.ts","webpack://mytonwallet/./src/util/random.ts","webpack://mytonwallet/./src/api/methods/staking.ts","webpack://mytonwallet/./src/api/methods/polling.ts","webpack://mytonwallet/./src/api/methods/accounts.ts","webpack://mytonwallet/./src/api/methods/wallet.ts","webpack://mytonwallet/./src/api/methods/auth.ts","webpack://mytonwallet/./src/api/methods/transactions.ts","webpack://mytonwallet/./src/api/methods/nfts.ts","webpack://mytonwallet/./src/api/methods/tokens.ts","webpack://mytonwallet/./src/api/tonConnect/types/index.ts","webpack://mytonwallet/./src/api/tonConnect/errors.ts","webpack://mytonwallet/./src/api/tonConnect/utils.ts","webpack://mytonwallet/./src/api/tonConnect/index.ts","webpack://mytonwallet/./src/api/tonConnect/sse.ts","webpack://mytonwallet/./src/api/methods/swap.ts","webpack://mytonwallet/./src/api/dappMethods/legacy.ts","webpack://mytonwallet/./src/api/methods/init.ts","webpack://mytonwallet/./src/api/providers/extension/providerForPopup.ts","webpack://mytonwallet/./src/api/providers/extension/config.ts","webpack://mytonwallet/./src/api/providers/extension/providerForContentScript.ts","webpack://mytonwallet/./src/util/iteratees.ts","webpack://mytonwallet/./src/util/logs.ts","webpack://mytonwallet/./src/util/schedulers.ts","webpack://mytonwallet/webpack/bootstrap","webpack://mytonwallet/webpack/runtime/compat get default export","webpack://mytonwallet/webpack/runtime/define property getters","webpack://mytonwallet/webpack/runtime/global","webpack://mytonwallet/webpack/runtime/hasOwnProperty shorthand","webpack://mytonwallet/webpack/runtime/make namespace object","webpack://mytonwallet/webpack/runtime/node module decorator","webpack://mytonwallet/webpack/runtime/jsonp chunk loading","webpack://mytonwallet/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","/*\n * This module is to be used instead of /src/util/environment.ts\n * when `window` is not available (e.g. in a web worker).\n */\n\n// eslint-disable-next-line no-restricted-globals\nexport const IS_EXTENSION = Boolean(self?.chrome?.runtime?.id);\n// eslint-disable-next-line no-restricted-globals\nexport const IS_CHROME_EXTENSION = Boolean(self?.chrome?.system);\nexport const IS_FIREFOX_EXTENSION = IS_EXTENSION && !IS_CHROME_EXTENSION;\n\nexport const IS_ELECTRON = process.env.IS_ELECTRON;\n\nexport const IS_DAPP_SUPPORTED = IS_EXTENSION || IS_ELECTRON;\n","import type { LangItem } from './global/types';\n\nexport const APP_NAME = process.env.APP_NAME || 'MyTonWallet';\nexport const APP_VERSION = process.env.APP_VERSION!;\n\nexport const DEBUG = (\n  process.env.APP_ENV !== 'production' && process.env.APP_ENV !== 'perf' && process.env.APP_ENV !== 'test'\n);\nexport const DEBUG_MORE = false;\n\nexport const IS_MOCKED_CLIENT = process.env.APP_MOCKED_CLIENT === '1';\nexport const IS_TEST = process.env.APP_ENV === 'test';\nexport const IS_PERF = process.env.APP_ENV === 'perf';\nexport const IS_ELECTRON = process.env.IS_ELECTRON;\nexport const IS_SSE_SUPPORTED = IS_ELECTRON;\n\nexport const ELECTRON_HOST_URL = 'https://dumb-host';\nexport const INACTIVE_MARKER = '[Inactive]';\n\nexport const DEBUG_ALERT_MSG = 'Shoot!\\nSomething went wrong, please see the error details in Dev Tools Console.';\n\nexport const MNEMONIC_COUNT = 24;\nexport const MNEMONIC_CHECK_COUNT = 3;\n\nexport const MOBILE_SCREEN_MAX_WIDTH = 700; // px\n\nexport const ANIMATION_END_DELAY = 50;\n\nexport const ANIMATED_STICKER_SMALL_SIZE_PX = 110;\nexport const ANIMATED_STICKER_MIDDLE_SIZE_PX = 120;\nexport const ANIMATED_STICKER_DEFAULT_PX = 150;\nexport const ANIMATED_STICKER_BIG_SIZE_PX = 156;\n\nexport const DEFAULT_PRICE_CURRENCY = '$';\nexport const CARD_SECONDARY_VALUE_SYMBOL = 'TON';\n\nexport const DEFAULT_LANDSCAPE_ACTION_TAB_ID = 1;\n\nexport const DEFAULT_DECIMAL_PLACES = 9;\n\nexport const TOKEN_INFO = {\n  toncoin: {\n    name: 'Toncoin',\n    symbol: CARD_SECONDARY_VALUE_SYMBOL,\n    slug: 'toncoin',\n    quote: {\n      price: 1.95,\n      percentChange1h: 0,\n      percentChange24h: 0,\n      percentChange7d: 0,\n      percentChange30d: 0,\n    },\n    decimals: DEFAULT_DECIMAL_PLACES,\n  },\n};\n\nexport const GLOBAL_STATE_CACHE_DISABLED = false;\nexport const GLOBAL_STATE_CACHE_KEY = 'mytonwallet-global-state';\n\nexport const ANIMATION_LEVEL_MIN = 0;\nexport const ANIMATION_LEVEL_MED = 1;\nexport const ANIMATION_LEVEL_MAX = 2;\nexport const ANIMATION_LEVEL_DEFAULT = ANIMATION_LEVEL_MAX;\nexport const THEME_DEFAULT = 'system';\n\nexport const MAIN_ACCOUNT_ID = '0-ton-mainnet';\n\nexport const TONHTTPAPI_MAINNET_URL = process.env.TONHTTPAPI_MAINNET_URL || 'https://toncenter.com/api/v2/jsonRPC';\nexport const TONHTTPAPI_MAINNET_API_KEY = (IS_ELECTRON && process.env.ELECTRON_TONHTTPAPI_MAINNET_API_KEY)\n  || process.env.TONHTTPAPI_MAINNET_API_KEY;\nexport const TONHTTPAPI_TESTNET_URL = process.env.TONHTTPAPI_TESTNET_URL\n  || 'https://testnet.toncenter.com/api/v2/jsonRPC';\nexport const TONHTTPAPI_TESTNET_API_KEY = (IS_ELECTRON && process.env.ELECTRON_TONHTTPAPI_TESTNET_API_KEY)\n  || process.env.TONHTTPAPI_TESTNET_API_KEY;\nexport const BRILLIANT_API_BASE_URL = process.env.BRILLIANT_API_BASE_URL || 'https://mytonwallet-api.herokuapp.com';\n\nexport const FRACTION_DIGITS = 9;\nexport const SHORT_FRACTION_DIGITS = 2;\n\nexport const MY_TON_WALLET_PROMO_URL = 'https://mytonwallet.io';\nexport const TELEGRAM_WEB_URL = 'https://web.telegram.org/a/';\nexport const TONSCAN_BASE_MAINNET_URL = 'https://tonscan.org/';\nexport const TONSCAN_BASE_TESTNET_URL = 'https://testnet.tonscan.org/';\nexport const GETGEMS_BASE_MAINNET_URL = 'https://getgems.io/';\nexport const GETGEMS_BASE_TESTNET_URL = 'https://testnet.getgems.io/';\n\nexport const TON_TOKEN_SLUG = 'toncoin';\n\nexport const PROXY_HOSTS = process.env.PROXY_HOSTS;\n\nexport const TINY_TRANSFER_MAX_AMOUNT = 0.01;\n\nexport const LANG_CACHE_NAME = 'mtw-lang-15';\n\nexport const LANG_LIST: LangItem[] = [{\n  langCode: 'en',\n  name: 'English',\n  nativeName: 'English',\n  rtl: false,\n}, {\n  langCode: 'es',\n  name: 'Spanish',\n  nativeName: 'Espaol',\n  rtl: false,\n}, {\n  langCode: 'ru',\n  name: 'Russian',\n  nativeName: '',\n  rtl: false,\n}, {\n  langCode: 'zh-Hans',\n  name: 'Chinese (Simplified)',\n  nativeName: '',\n  rtl: false,\n}, {\n  langCode: 'zh-Hant',\n  name: 'Chinese (Traditional)',\n  nativeName: '',\n  rtl: false,\n}];\n\nexport const STAKING_CYCLE_DURATION_MS = 129600000; // 36 hours\nexport const MIN_BALANCE_FOR_UNSTAKE = 1.02;\n\nexport const STAKING_POOLS = process.env.STAKING_POOLS ? process.env.STAKING_POOLS.split(' ') : [];\n","import extension from '../lib/webextension-polyfill';\n\nimport { DETACHED_TAB_URL } from './ledger/tab';\nimport { logDebugError } from './logs';\n\nimport type {\n  ApiUpdate,\n  CancellableCallback, OriginMessageData, OriginMessageEvent, WorkerMessageData,\n} from './PostMessageConnector';\n\ndeclare const self: WorkerGlobalScope;\n\nconst callbackState = new Map<string, CancellableCallback>();\n\ntype ApiConfig =\n  ((name: string, ...args: any[]) => any | [any, ArrayBuffer[]])\n  | Record<string, Function>;\ntype SendToOrigin = (data: WorkerMessageData, transferables?: Transferable[]) => void;\n\nexport function createWorkerInterface(api: ApiConfig, channel?: string) {\n  function sendToOrigin(data: WorkerMessageData, transferables?: Transferable[]) {\n    data.channel = channel;\n\n    if (transferables) {\n      postMessage(data, transferables);\n    } else {\n      postMessage(data);\n    }\n  }\n\n  handleErrors(sendToOrigin);\n\n  onmessage = (message: OriginMessageEvent) => {\n    if (message.data?.channel === channel) {\n      onMessage(api, message.data, sendToOrigin);\n    }\n  };\n}\n\nexport function createExtensionInterface(\n  portName: string,\n  api: ApiConfig,\n  channel?: string,\n  cleanUpdater?: (onUpdate: (update: ApiUpdate) => void) => void,\n  withAutoInit = false,\n) {\n  extension.runtime.onConnect.addListener((port) => {\n    if (port.name !== portName) {\n      return;\n    }\n\n    /**\n     * If the sender's URL includes the DETACHED_TAB_URL, we skip further processing\n     * This condition ensures that we don't interact with tabs that have already been closed.\n     */\n    const url = port.sender?.url;\n    if (url?.includes(DETACHED_TAB_URL)) {\n      return;\n    }\n\n    const origin = url ? new URL(url).origin : undefined;\n\n    const dAppUpdater = (update: ApiUpdate) => {\n      sendToOrigin({\n        type: 'update',\n        update,\n      });\n    };\n\n    function sendToOrigin(data: WorkerMessageData) {\n      data.channel = channel;\n      port.postMessage(data);\n    }\n\n    handleErrors(sendToOrigin);\n\n    port.onMessage.addListener((data: OriginMessageData) => {\n      if (data.channel === channel) {\n        onMessage(api, data, sendToOrigin, dAppUpdater, origin);\n      }\n    });\n\n    port.onDisconnect.addListener(() => {\n      cleanUpdater?.(dAppUpdater);\n    });\n\n    if (withAutoInit) {\n      onMessage(api, { type: 'init', name: 'init', args: [] }, sendToOrigin, dAppUpdater);\n    }\n  });\n}\n\nasync function onMessage(\n  api: ApiConfig,\n  data: OriginMessageData,\n  sendToOrigin: SendToOrigin,\n  onUpdate?: (update: ApiUpdate) => void,\n  origin?: string,\n) {\n  if (!onUpdate) {\n    onUpdate = (update: ApiUpdate) => {\n      sendToOrigin({\n        type: 'update',\n        update,\n      });\n    };\n  }\n\n  switch (data.type) {\n    case 'init': {\n      const { args } = data;\n      const promise = typeof api === 'function'\n        ? api('init', origin, onUpdate, ...args)\n        : api.init?.(onUpdate, ...args);\n      await promise;\n\n      break;\n    }\n    case 'callMethod': {\n      const {\n        messageId, name, args, withCallback,\n      } = data;\n      try {\n        if (messageId && withCallback) {\n          const callback = (...callbackArgs: any[]) => {\n            const lastArg = callbackArgs[callbackArgs.length - 1];\n\n            sendToOrigin({\n              type: 'methodCallback',\n              messageId,\n              callbackArgs,\n            }, isTransferable(lastArg) ? [lastArg] : undefined);\n          };\n\n          callbackState.set(messageId, callback);\n\n          args.push(callback as never);\n        }\n\n        const response = typeof api === 'function'\n          ? await api(name, origin, ...args)\n          : await api[name](...args);\n        const { arrayBuffer } = (typeof response === 'object' && 'arrayBuffer' in response && response) || {};\n\n        if (messageId) {\n          sendToOrigin(\n            {\n              type: 'methodResponse',\n              messageId,\n              response,\n            },\n            arrayBuffer ? [arrayBuffer] : undefined,\n          );\n        }\n      } catch (err: any) {\n        logDebugError('onMessage:callMethod', err);\n\n        if (messageId) {\n          sendToOrigin({\n            type: 'methodResponse',\n            messageId,\n            error: { message: err.message },\n          });\n        }\n      }\n\n      if (messageId) {\n        callbackState.delete(messageId);\n      }\n\n      break;\n    }\n    case 'cancelProgress': {\n      const callback = callbackState.get(data.messageId);\n      if (callback) {\n        callback.isCanceled = true;\n      }\n\n      break;\n    }\n  }\n}\n\nfunction isTransferable(obj: any) {\n  return obj instanceof ArrayBuffer || obj instanceof ImageBitmap;\n}\n\nfunction handleErrors(sendToOrigin: SendToOrigin) {\n  self.onerror = (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.error?.message || 'Uncaught exception in worker' } });\n  };\n\n  self.addEventListener('unhandledrejection', (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.reason?.message || 'Uncaught rejection in worker' } });\n  });\n}\n","import extension from '../../lib/webextension-polyfill';\n\nexport const DETACHED_TAB_URL = '#detached';\n\nexport function openLedgerTab() {\n  return createLedgerTab();\n}\n\nexport function onLedgerTabClose(id: number, onClose: () => void) {\n  extension.tabs.onRemoved.addListener((closedTabId: number) => {\n    if (closedTabId !== id) {\n      return;\n    }\n\n    onClose();\n  });\n}\n\nasync function createLedgerTab() {\n  const tab = await extension.tabs.create({ url: `index.html${DETACHED_TAB_URL}`, active: true });\n  await extension.windows.update(tab.windowId!, { focused: true });\n  return tab.id!;\n}\n","import type { AccountIdParsed, ApiBlockchainKey, ApiNetwork } from '../api/types';\n\nexport function genRelatedAccountIds(accountId: string): string[] {\n  const account = parseAccountId(accountId);\n  return [\n    buildAccountId({ ...account, network: 'mainnet' }),\n    buildAccountId({ ...account, network: 'testnet' }),\n  ];\n}\n\nexport function parseAccountId(accountId: string): AccountIdParsed {\n  const [\n    id,\n    blockchain = 'ton', // Handle deprecated case when `accountId = '0'`\n    network = 'mainnet',\n  ] = accountId.split('-');\n  return {\n    id: Number(id),\n    blockchain: blockchain as ApiBlockchainKey,\n    network: network as ApiNetwork,\n  };\n}\n\nexport function buildAccountId(account: AccountIdParsed) {\n  const { id, network, blockchain } = account;\n  return `${id}-${blockchain}-${network}`;\n}\n","import { StorageType } from './types';\n\nimport { IS_EXTENSION } from '../environment';\nimport extensionStorage from './extension';\nimport idb from './idb';\nimport localStorage from './localStorage';\n\nexport const storage = IS_EXTENSION ? extensionStorage : idb;\n\nexport default {\n  [StorageType.IndexedDb]: idb,\n  [StorageType.LocalStorage]: localStorage,\n  [StorageType.ExtensionLocal]: extensionStorage,\n};\n","import TonWeb from 'tonweb';\n\nimport { STAKING_POOLS } from '../../config';\n\nexport function bytesToHex(bytes: Uint8Array) {\n  return TonWeb.utils.bytesToHex(bytes);\n}\n\nexport function hexToBytes(hex: string) {\n  return TonWeb.utils.hexToBytes(hex);\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  return TonWeb.utils.bytesToBase64(bytes);\n}\n\nexport function base64ToBytes(hex: string) {\n  return TonWeb.utils.base64ToBytes(hex);\n}\n\nexport function hexToBase64(hex: string) {\n  return bytesToBase64(hexToBytes(hex));\n}\n\nexport function base64ToString(base64: string) {\n  return TonWeb.utils.base64toString(base64);\n}\n\nexport function sha256(bytes: Uint8Array) {\n  return TonWeb.utils.sha256(bytes);\n}\n\nexport function handleFetchErrors(response: Response) {\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n  return response;\n}\n\nexport function sumBigString(a: string, b: string) {\n  return (BigInt(a) + BigInt(b)).toString();\n}\n\nexport function isKnownStakingPool(address: string) {\n  return STAKING_POOLS.some((poolPart) => address.endsWith(poolPart));\n}\n","import { BRILLIANT_API_BASE_URL } from '../../config';\nimport { handleFetchErrors } from './utils';\n\nexport async function callBackendPost(path: string, data: AnyLiteral) {\n  const response = await fetch(`${BRILLIANT_API_BASE_URL}${path}`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data),\n  });\n  handleFetchErrors(response);\n  return response.json();\n}\n\nexport async function callBackendGet(path: string, data?: AnyLiteral, headers?: AnyLiteral) {\n  const url = new URL(`${BRILLIANT_API_BASE_URL}${path}`);\n  if (data) {\n    Object.entries(data).forEach(([key, value]) => {\n      url.searchParams.set(key, value.toString());\n    });\n  }\n\n  const response = await fetch(url, { headers });\n  handleFetchErrors(response);\n  return response.json();\n}\n","import type { ApiKnownAddresses } from '../types';\n\nimport { mapValues } from '../../util/iteratees';\nimport { logDebugError } from '../../util/logs';\nimport { callBackendGet } from './backend';\n\nlet knownAddresses: ApiKnownAddresses;\nlet scamMarkers: RegExp[];\n\nexport async function tryUpdateKnownAddresses() {\n  try {\n    const data = await callBackendGet('/known-addresses');\n\n    knownAddresses = mapValues(data.knownAddresses as Record<string, string | any>, (value) => {\n      return typeof value === 'string' ? { name: value } : value;\n    });\n    scamMarkers = (data.scamMarkers as string[]).map((x) => new RegExp(x, 'i'));\n  } catch (err) {\n    logDebugError('tryUpdateKnownAddresses', err);\n  }\n}\n\nexport function getKnownAddresses() {\n  return knownAddresses;\n}\n\nexport function getScamMarkers() {\n  return scamMarkers;\n}\n\nexport function getAddressInfo(address: string) {\n  return knownAddresses[address];\n}\n","import type { ApiTransaction } from '../types';\n\nimport { createCallbackManager } from '../../util/callbacks';\n\nexport const txCallbacks = createCallbackManager();\n\nexport function whenTxComplete(toAddress: string, amount: string) {\n  return new Promise<{ result: boolean; txId: string }>((resolve) => {\n    txCallbacks.addCallback(function callback(transaction: ApiTransaction) {\n      if (transaction.toAddress === toAddress && transaction.amount === `-${amount}`) {\n        txCallbacks.removeCallback(callback);\n        resolve({ result: true, txId: transaction.txId });\n      }\n    });\n  });\n}\n","import type { ApiTransactionExtra } from '../blockchains/ton/types';\nimport type { StorageKey } from '../storages/types';\nimport type {\n  AccountIdParsed, ApiLocalTransactionParams, ApiTransaction, OnApiUpdate,\n} from '../types';\n\nimport { MAIN_ACCOUNT_ID } from '../../config';\nimport { parseAccountId } from '../../util/account';\nimport { IS_EXTENSION } from '../environment';\nimport { storage } from '../storages';\nimport idbStorage from '../storages/idb';\nimport { getKnownAddresses, getScamMarkers } from './addresses';\nimport { whenTxComplete } from './txCallbacks';\n\nlet localCounter = 0;\nconst getNextLocalId = () => `${Date.now()}|${localCounter++}`;\n\nconst actualStateVersion = 6;\nlet migrationEnsurePromise: Promise<void>;\n\nexport function resolveBlockchainKey(accountId: string) {\n  return parseAccountId(accountId).blockchain;\n}\n\nexport function toInternalAccountId(accountId: string) {\n  return buildInternalAccountId(parseAccountId(accountId));\n}\n\nexport function buildInternalAccountId(account: Omit<AccountIdParsed, 'network'>) {\n  const { id, blockchain } = account;\n  return `${id}-${blockchain}`;\n}\n\nexport function createLocalTransaction(onUpdate: OnApiUpdate, accountId: string, params: ApiLocalTransactionParams) {\n  const {\n    amount, fromAddress, toAddress, comment, fee, slug, type, encryptedComment,\n  } = params;\n\n  const localTransaction = buildLocalTransaction({\n    amount,\n    fromAddress,\n    toAddress,\n    comment,\n    fee,\n    slug,\n    type,\n    encryptedComment,\n  });\n\n  onUpdate({\n    type: 'newLocalTransaction',\n    transaction: localTransaction,\n    accountId,\n  });\n\n  whenTxComplete(toAddress, amount)\n    .then(({ txId }) => {\n      onUpdate({\n        type: 'updateTxComplete',\n        accountId,\n        toAddress,\n        amount,\n        txId,\n        localTxId: localTransaction.txId,\n      });\n    });\n\n  return localTransaction;\n}\n\nfunction buildLocalTransaction(params: ApiLocalTransactionParams): ApiTransaction {\n  const { amount, ...restParams } = params;\n\n  return updateTransactionMetadata({\n    txId: getNextLocalId(),\n    timestamp: Date.now(),\n    isIncoming: false,\n    amount: `-${amount}`,\n    ...restParams,\n  });\n}\n\nexport function updateTransactionMetadata(transaction: ApiTransactionExtra): ApiTransactionExtra {\n  const {\n    isIncoming, fromAddress, toAddress, comment,\n  } = transaction;\n  let { metadata = {} } = transaction;\n\n  const knownAddresses = getKnownAddresses();\n  const scamMarkers = getScamMarkers();\n\n  const address = isIncoming ? fromAddress : toAddress;\n  if (address in knownAddresses) {\n    metadata = { ...metadata, ...knownAddresses[address] };\n  }\n\n  if (comment && scamMarkers.map((sm) => sm.test(comment)).find(Boolean)) {\n    metadata.isScam = true;\n  }\n\n  return { ...transaction, metadata };\n}\n\nlet currentOnUpdate: OnApiUpdate | undefined;\n\nexport function connectUpdater(onUpdate: OnApiUpdate) {\n  currentOnUpdate = onUpdate;\n}\n\nexport function disconnectUpdater() {\n  currentOnUpdate = undefined;\n}\n\nexport function isUpdaterAlive(onUpdate: OnApiUpdate) {\n  return currentOnUpdate === onUpdate;\n}\n\nexport function startStorageMigration() {\n  migrationEnsurePromise = migrateStorage();\n  return migrationEnsurePromise;\n}\n\nexport function waitStorageMigration() {\n  return migrationEnsurePromise;\n}\n\nexport async function migrateStorage() {\n  let version = Number(await storage.getItem('stateVersion'));\n\n  if (version === actualStateVersion) {\n    return;\n  }\n\n  if (!version && !(await storage.getItem('addresses'))) {\n    version = await idbStorage.getItem('stateVersion');\n\n    if (IS_EXTENSION && version) {\n      // Switching from IndexedDB to `chrome.storage.local`\n      const idbData = await idbStorage.getAll!();\n      await storage.setMany!(idbData);\n    } else {\n      await storage.setItem('stateVersion', actualStateVersion);\n      return;\n    }\n  }\n\n  // First version (v1)\n  if (!version) {\n    // Support multi-accounts\n    const mnemonicEncrypted = await storage.getItem('mnemonicEncrypted' as StorageKey);\n    if (mnemonicEncrypted) {\n      await storage.setItem('mnemonicsEncrypted', JSON.stringify({\n        [MAIN_ACCOUNT_ID]: mnemonicEncrypted,\n      }));\n      await storage.removeItem('mnemonicEncrypted' as StorageKey);\n    }\n\n    // Change accountId format ('0' -> '0-ton', '1-ton-mainnet' -> '1-ton')\n    if (!mnemonicEncrypted) {\n      for (const field of ['mnemonicsEncrypted', 'addresses', 'publicKeys'] as StorageKey[]) {\n        const raw = await storage.getItem(field);\n        if (!raw) continue;\n\n        const oldItem = JSON.parse(raw);\n        const newItem = Object.entries(oldItem).reduce((prevValue, [accountId, data]) => {\n          prevValue[toInternalAccountId(accountId)] = data;\n          return prevValue;\n        }, {} as any);\n\n        await storage.setItem(field, JSON.stringify(newItem));\n      }\n    }\n\n    version = 1;\n    await storage.setItem('stateVersion', version);\n  }\n\n  if (version === 1) {\n    const addresses = await storage.getItem('addresses') as string | undefined;\n    if (addresses && addresses.includes('-undefined')) {\n      for (const field of ['mnemonicsEncrypted', 'addresses', 'publicKeys'] as StorageKey[]) {\n        const newValue = (await storage.getItem(field) as string).replace('-undefined', '-ton');\n        await storage.setItem(field, newValue);\n      }\n    }\n\n    version = 2;\n    await storage.setItem('stateVersion', version);\n  }\n\n  if (version >= 2 && version <= 4) {\n    for (const key of ['addresses', 'mnemonicsEncrypted', 'publicKeys', 'dapps'] as StorageKey[]) {\n      const rawData = await storage.getItem(key);\n      if (typeof rawData === 'string') {\n        await storage.setItem(key, JSON.parse(rawData));\n      }\n    }\n\n    version = 5;\n    await storage.setItem('stateVersion', version);\n  }\n\n  if (version === 5) {\n    const dapps = await storage.getItem('dapps');\n    if (dapps) {\n      for (const accountDapps of Object.values(dapps) as any[]) {\n        for (const dapp of Object.values(accountDapps) as any[]) {\n          dapp.connectedAt = 1;\n        }\n      }\n      await storage.setItem('dapps', dapps);\n    }\n\n    version = 6;\n    await storage.setItem('stateVersion', version);\n  }\n}\n","import type { StorageKey } from '../storages/types';\nimport type { ApiAccountInfo, ApiNetwork } from '../types';\n\nimport { buildAccountId, parseAccountId } from '../../util/account';\nimport { buildCollectionByKey } from '../../util/iteratees';\nimport { storage } from '../storages';\nimport { toInternalAccountId } from './helpers';\n\nconst MIN_ACCOUNT_NUMBER = 0;\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let loginResolve: AnyFunction;\nconst loginPromise = new Promise<void>((resolve) => {\n  loginResolve = resolve;\n});\n\nexport async function getAccountIds(): Promise<string[]> {\n  return Object.keys(await storage.getItem('addresses') || {});\n}\n\nexport async function getMainAccountId() {\n  const accountIds = await getAccountIds();\n\n  const accounts = await Promise.all(\n    accountIds.map(async (accountId) => {\n      const info = await fetchStoredAccount(accountId);\n      return {\n        ...parseAccountId(accountId),\n        accountId,\n        hasLedger: !!info?.ledger,\n      };\n    }),\n  );\n\n  const nonHardwareAccounts = accounts.filter((account) => !account.hasLedger);\n\n  if (!nonHardwareAccounts.length) {\n    return undefined;\n  }\n\n  const accountById = buildCollectionByKey(\n    nonHardwareAccounts,\n    'id',\n  );\n\n  const keys = Object.keys(accountById);\n  if (!keys.length) {\n    return undefined;\n  }\n\n  const id = Math.min(...keys.map(Number));\n\n  return accountById[id].accountId;\n}\n\nexport async function getNewAccountId(network: ApiNetwork) {\n  const ids = (await getAccountIds()).map((accountId) => parseAccountId(accountId).id);\n  const id = ids.length === 0 ? MIN_ACCOUNT_NUMBER : Math.max(...ids) + 1;\n  return buildAccountId({\n    id,\n    network,\n    blockchain: 'ton',\n  });\n}\n\nexport function fetchStoredAccount(accountId: string): Promise<ApiAccountInfo | undefined> {\n  return getAccountValue(accountId, 'accounts');\n}\n\nexport function fetchStoredPublicKey(accountId: string): Promise<string> {\n  return getAccountValue(accountId, 'publicKeys');\n}\n\nexport function fetchStoredAddress(accountId: string): Promise<string> {\n  return getAccountValue(accountId, 'addresses');\n}\n\nexport async function getAccountValue(accountId: string, key: StorageKey) {\n  const internalId = toInternalAccountId(accountId);\n  return (await storage.getItem(key))?.[internalId];\n}\n\nexport async function removeAccountValue(accountId: string, key: StorageKey) {\n  const internalId = toInternalAccountId(accountId);\n  const data = await storage.getItem(key);\n  if (!data) return;\n\n  const { [internalId]: removedValue, ...restData } = data;\n  await storage.setItem(key, restData);\n}\n\nexport async function setAccountValue(accountId: string, key: StorageKey, value: any) {\n  const internalId = toInternalAccountId(accountId);\n  const data = await storage.getItem(key);\n  await storage.setItem(key, { ...data, [internalId]: value });\n}\n\nexport function getCurrentAccountId(): Promise<string | undefined> {\n  return storage.getItem('currentAccountId');\n}\n\nexport function waitLogin() {\n  return loginPromise;\n}\n","import * as tonWebMnemonic from 'tonweb-mnemonic';\nimport nacl from 'tweetnacl';\n\nimport { logDebugError } from '../../../util/logs';\nimport { getAccountValue } from '../../common/accounts';\nimport {\n  base64ToBytes,\n  bytesToBase64,\n  bytesToHex,\n  hexToBytes,\n} from '../../common/utils';\n\nexport function generateMnemonic() {\n  return tonWebMnemonic.generateMnemonic();\n}\n\nexport function validateMnemonic(mnemonic: string[]) {\n  return tonWebMnemonic.validateMnemonic(mnemonic);\n}\n\nexport async function mnemonicToSeed(mnemonic: string[]) {\n  const keyPair = await tonWebMnemonic.mnemonicToKeyPair(mnemonic);\n  return bytesToBase64(keyPair.secretKey.slice(0, 32));\n}\n\nexport function seedToKeyPair(seed: string) {\n  return nacl.sign.keyPair.fromSeed(base64ToBytes(seed));\n}\n\nexport async function encryptMnemonic(mnemonic: string[], password: string) {\n  const plaintext = mnemonic.join(',');\n  const pwUtf8 = new TextEncoder().encode(password); // encode password as UTF-8\n  const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8); // hash the password\n  const iv = crypto.getRandomValues(new Uint8Array(12)); // get 96-bit random iv\n  const alg = { name: 'AES-GCM', iv }; // specify algorithm to use\n  const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['encrypt']); // generate key from pw\n  const ptUint8 = new TextEncoder().encode(plaintext); // encode plaintext as UTF-8\n  const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8); // encrypt plaintext using key\n  const ctArray = Array.from(new Uint8Array(ctBuffer)); // ciphertext as byte array\n  const ctStr = ctArray.map((byte) => String.fromCharCode(byte)).join(''); // ciphertext as string\n  // TODO Try `ctArray.toString('base64')` or `ctBuffer.toString('base64')`\n  const ctBase64 = btoa(ctStr); // encode ciphertext as base64\n  const ivHex = Array.from(iv).map((b) => (`00${b.toString(16)}`).slice(-2)).join(''); // iv as hex string\n\n  return ivHex + ctBase64; // return iv+ciphertext\n}\n\nexport async function decryptMnemonic(encrypted: string, password: string) {\n  const pwUtf8 = new TextEncoder().encode(password); // encode password as UTF-8\n  const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8); // hash the password\n  const iv = encrypted.slice(0, 24).match(/.{2}/g)!.map((byte) => parseInt(byte, 16)); // get iv from ciphertext\n  const alg = { name: 'AES-GCM', iv: new Uint8Array(iv) }; // specify algorithm to use\n  const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']); // use pw to generate key\n  const ctStr = atob(encrypted.slice(24)); // decode base64 ciphertext\n  const ctUint8 = new Uint8Array(ctStr.match(/[\\s\\S]/g)!.map((ch) => ch.charCodeAt(0))); // ciphertext as Uint8Array\n  // note: why doesn't ctUint8 = new TextEncoder().encode(ctStr) work?\n  const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8); // decrypt ciphertext using key\n  const plaintext = new TextDecoder().decode(plainBuffer); // decode password from UTF-8\n  return plaintext.split(',');\n}\n\nexport async function fetchMnemonic(accountId: string, password: string) {\n  try {\n    const mnemonicEncrypted = await getAccountValue(accountId, 'mnemonicsEncrypted');\n    return await decryptMnemonic(mnemonicEncrypted, password);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n\n    return undefined;\n  }\n}\n\nexport async function fetchPrivateKey(accountId: string, password: string) {\n  try {\n    const mnemonic = await fetchMnemonic(accountId, password);\n    if (!mnemonic) {\n      return undefined;\n    }\n\n    const seedBase64 = await mnemonicToSeed(mnemonic);\n    const { secretKey: privateKey } = seedToKeyPair(seedBase64);\n\n    return privateKey;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n\n    return undefined;\n  }\n}\n\nexport async function fetchKeyPair(accountId: string, password: string) {\n  try {\n    const mnemonic = await fetchMnemonic(accountId, password);\n    if (!mnemonic) {\n      return undefined;\n    }\n\n    return await tonWebMnemonic.mnemonicToKeyPair(mnemonic);\n  } catch (err) {\n    logDebugError('fetchKeyPair', err);\n\n    return undefined;\n  }\n}\n\nexport async function rawSign(accountId: string, password: string, dataHex: string) {\n  const privateKey = await fetchPrivateKey(accountId, password);\n  if (!privateKey) {\n    return undefined;\n  }\n\n  const signature = nacl.sign.detached(hexToBytes(dataHex), privateKey);\n\n  return bytesToHex(signature);\n}\n\nexport async function verifyPassword(accountId: string, password: string) {\n  const mnemonic = await fetchMnemonic(accountId, password);\n\n  return Boolean(mnemonic);\n}\n","import {\n  AccountsApi,\n  BlockchainApi,\n  Configuration,\n  NFTApi,\n  ResponseError,\n} from 'tonapi-sdk-js';\n\nimport type { ApiNetwork } from '../../../types';\n\nimport { logDebugError } from '../../../../util/logs';\n\nconst TONAPIIO_MAINNET_URL = process.env.TONAPIIO_MAINNET_URL || 'https://tonapi.io';\nconst TONAPIIO_TESTNET_URL = process.env.TONAPIIO_TESTNET_URL || 'https://testnet.tonapi.io';\nconst MAX_LIMIT = 1000;\n\nconst configurationMainnet = new Configuration({\n  basePath: TONAPIIO_MAINNET_URL,\n});\nconst configurationTestnet = new Configuration({\n  basePath: TONAPIIO_TESTNET_URL,\n});\n\nexport const tonapiioByNetwork = {\n  mainnet: {\n    configuration: configurationMainnet,\n    blockchainApi: new BlockchainApi(configurationMainnet),\n    nftApi: new NFTApi(configurationMainnet),\n    accountsApi: new AccountsApi(configurationMainnet),\n  },\n  testnet: {\n    configuration: configurationTestnet,\n    blockchainApi: new BlockchainApi(configurationTestnet),\n    nftApi: new NFTApi(configurationTestnet),\n    accountsApi: new AccountsApi(configurationTestnet),\n  },\n};\n\nexport function fetchJettonBalances(network: ApiNetwork, account: string) {\n  const api = tonapiioByNetwork[network].accountsApi;\n  return tonapiioErrorHandler(async () => {\n    return (await api.getJettonsBalances({ accountId: account })).balances;\n  }, []);\n}\n\nexport function fetchNftItems(network: ApiNetwork, addresses: string[]) {\n  const api = tonapiioByNetwork[network].nftApi;\n  return tonapiioErrorHandler(async () => (await api.getNftItemsByAddresses({\n    getAccountsRequest: { accountIds: addresses },\n  })).nftItems, []);\n}\n\nexport function fetchAccountNfts(network: ApiNetwork, address: string, offset?: number, limit?: number) {\n  const api = tonapiioByNetwork[network].accountsApi;\n  return tonapiioErrorHandler(async () => (await api.getNftItemsByOwner({\n    accountId: address,\n    offset: offset ?? 0,\n    limit: limit ?? MAX_LIMIT,\n    indirectOwnership: true,\n  })).nftItems, []);\n}\n\nexport function fetchAccountEvents(network: ApiNetwork, address: string, fromSec: number, limit?: number) {\n  const api = tonapiioByNetwork[network].accountsApi;\n  return tonapiioErrorHandler(async () => (await api.getEventsByAccount({\n    accountId: address,\n    limit: limit ?? MAX_LIMIT,\n    startDate: fromSec,\n  })).events, []);\n}\n\nasync function tonapiioErrorHandler<T>(fn: () => Promise<T>, defaultValue: T): Promise<T> {\n  try {\n    return (await fn()) || defaultValue;\n  } catch (err: any) {\n    if (err instanceof ResponseError) {\n      const data = await err.response.json().catch();\n      if (data?.error === 'entity not found') {\n        return defaultValue;\n      }\n    }\n    logDebugError('tonapiioErrorHandler', err);\n    throw err;\n  }\n}\n","import type { ApiParsedPayload } from '../../types';\n\nexport const TOKEN_TRANSFER_TON_AMOUNT = 50000000n; // 0.05 TON\nexport const TOKEN_TRANSFER_TON_FORWARD_AMOUNT = 1n; // 0.000000001 TON\n\nexport const STAKE_COMMENT = 'd';\nexport const UNSTAKE_COMMENT = 'w';\n\nexport const ATTEMPTS = 5;\n\nexport const DEFAULT_DECIMALS = 9;\n\nexport const LEDGER_SUPPORTED_PAYLOADS: ApiParsedPayload['type'][] = [\n  'transfer-nft',\n  'transfer-tokens',\n  'comment',\n];\n\nexport enum OpCode {\n  Comment = 0,\n  Encrypted = 0x2167da4b,\n}\n\nexport enum JettonOpCode {\n  Transfer = 0xf8a7ea5,\n  TransferNotification = 0x7362d09c,\n  InternalTransfer = 0x178d4519,\n  Excesses = 0xd53276db,\n  Burn = 0x595f07bc,\n  BurnNotification = 0x7bdd97de,\n}\n\nexport enum NftOpCode {\n  TransferOwnership = 0x5fcc3d14,\n}\n","export function cloneDeep<T>(value: T): T {\n  return JSON.parse(JSON.stringify(value));\n}\n\nexport function stringifyTxId({ lt, hash }: { lt: number; hash: string }) {\n  return `${lt}:${hash}`;\n}\n\nexport function parseTxId(txId: string): { lt: number; hash: string } {\n  const [lt, hash] = txId.split(':');\n  return { lt: Number(lt), hash };\n}\n\nexport function buildTokenSlug(minterAddress: string) {\n  const addressPart = minterAddress.replace(/[^a-z\\d]/gi, '').slice(0, 10);\n  return `ton-${addressPart}`.toLowerCase();\n}\n","import type { AddressType } from 'tonweb';\nimport TonWeb from 'tonweb';\nimport type { Cell as CellType } from 'tonweb/dist/types/boc/cell';\nimport type { JettonData } from 'tonweb/dist/types/contract/token/ft/jetton-minter';\nimport BN from 'bn.js';\n\nimport type { ApiNetwork } from '../../../types';\nimport type { ApiTransactionExtra, MyTonWeb, TokenTransferBodyParams } from '../types';\n\nimport {\n  TON_TOKEN_SLUG,\n  TONHTTPAPI_MAINNET_API_KEY,\n  TONHTTPAPI_MAINNET_URL,\n  TONHTTPAPI_TESTNET_API_KEY,\n  TONHTTPAPI_TESTNET_URL,\n} from '../../../../config';\nimport withCacheAsync from '../../../../util/withCacheAsync';\nimport { hexToBytes } from '../../../common/utils';\nimport { JettonOpCode } from '../constants';\nimport { parseTxId, stringifyTxId } from './index';\n\nimport CustomHttpProvider from './CustomHttpProvider';\n\nconst { Cell } = TonWeb.boc;\nconst { Address } = TonWeb.utils;\nconst { JettonMinter, JettonWallet } = TonWeb.token.jetton;\n\nconst tonwebByNetwork = {\n  mainnet: new TonWeb(new CustomHttpProvider(TONHTTPAPI_MAINNET_URL, {\n    apiKey: TONHTTPAPI_MAINNET_API_KEY,\n  })) as MyTonWeb,\n  testnet: new TonWeb(new CustomHttpProvider(TONHTTPAPI_TESTNET_URL, {\n    apiKey: TONHTTPAPI_TESTNET_API_KEY,\n  })) as MyTonWeb,\n};\n\nexport const resolveTokenWalletAddress = withCacheAsync(\n  async (network: ApiNetwork, address: string, minterAddress: string) => {\n    const minter = new JettonMinter(getTonWeb(network).provider, { address: minterAddress } as any);\n    return toBase64Address(await minter.getJettonWalletAddress(new Address(address)));\n  },\n);\n\nexport const resolveTokenMinterAddress = withCacheAsync(async (network: ApiNetwork, tokenWalletAddress: string) => {\n  const tokenWallet = new JettonWallet(getTonWeb(network).provider, { address: tokenWalletAddress } as any);\n  return toBase64Address((await tokenWallet.getData()).jettonMinterAddress);\n});\n\nexport const getWalletPublicKey = withCacheAsync(async (network: ApiNetwork, address: string) => {\n  try {\n    const publicKeyBN = await getTonWeb(network).provider.call2(address, 'get_public_key');\n    let publicKeyHex = publicKeyBN.toString(16);\n    if (publicKeyHex.length % 2 !== 0) {\n      publicKeyHex = `0${publicKeyHex}`;\n    }\n\n    return hexToBytes(publicKeyHex);\n  } catch (err) {\n    return undefined;\n  }\n});\n\nexport async function getJettonMinterData(network: ApiNetwork, address: string) {\n  const contract = new JettonMinter(getTonWeb(network).provider, { address } as any);\n  const data = await contract.getJettonData() as JettonData & {\n    jettonContentCell: CellType;\n  };\n  return {\n    ...data,\n    totalSupply: data.totalSupply.toString(),\n    adminAddress: data.adminAddress ? toBase64Address(data.adminAddress) : undefined,\n  };\n}\n\nexport async function fetchNewestTxId(network: ApiNetwork, address: string) {\n  const tonWeb = getTonWeb(network);\n\n  const result: any[] = await tonWeb.provider.getTransactions(\n    address,\n    1,\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  if (!result?.length) {\n    return undefined;\n  }\n\n  return stringifyTxId(result[0].transaction_id);\n}\n\nexport async function fetchTransactions(\n  network: ApiNetwork, address: string, limit: number, fromTxId?: string, toTxId?: string,\n): Promise<ApiTransactionExtra[]> {\n  const tonWeb = getTonWeb(network);\n\n  const fromLt = fromTxId ? parseTxId(fromTxId).lt : undefined;\n  const fromHash = fromTxId ? parseTxId(fromTxId).hash : undefined;\n  const toLt = toTxId ? parseTxId(toTxId).lt : undefined;\n\n  const rawTransactions = await tonWeb.provider.getTransactions(\n    address, limit, fromLt, fromHash, toLt, true,\n  );\n\n  return rawTransactions.map(parseRawTransaction).flat();\n}\n\nfunction parseRawTransaction(rawTx: any): ApiTransactionExtra[] {\n  const {\n    utime,\n    transaction_id: {\n      lt,\n      hash,\n    },\n    fee,\n  } = rawTx;\n  const txId = stringifyTxId({ lt, hash });\n  const timestamp = utime as number * 1000;\n  const isIncoming = !!rawTx.in_msg.source;\n  const msgs: any[] = isIncoming ? [rawTx.in_msg] : rawTx.out_msgs;\n\n  if (!msgs.length) return [];\n\n  return msgs.map((msg, i) => {\n    const { source, destination, value } = msg;\n    return {\n      txId: msgs.length > 1 ? `${txId}:${i + 1}` : txId,\n      timestamp,\n      isIncoming,\n      fromAddress: source,\n      toAddress: destination,\n      amount: isIncoming ? value : `-${value}`,\n      comment: getComment(msg),\n      encryptedComment: getEncryptedComment(msg),\n      slug: TON_TOKEN_SLUG,\n      fee,\n      extraData: {\n        body: getRawBody(msg),\n      },\n    };\n  });\n}\n\nfunction getComment(msg: any): string | undefined {\n  if (!msg.msg_data) return undefined;\n  if (msg.msg_data['@type'] !== 'msg.dataText') return undefined;\n  const base64 = msg.msg_data.text;\n  return new TextDecoder().decode(TonWeb.utils.base64ToBytes(base64));\n}\n\nfunction getEncryptedComment(msg: any): string | undefined {\n  if (!msg.msg_data) return undefined;\n  if (msg.msg_data['@type'] !== 'msg.dataEncryptedText') return undefined;\n  return msg.msg_data.text;\n}\n\nfunction getRawBody(msg: any) {\n  if (!msg.msg_data) return undefined;\n  if (msg.msg_data['@type'] !== 'msg.dataRaw') return undefined;\n  return msg.msg_data.body;\n}\n\nexport function getTonWeb(network: ApiNetwork = 'mainnet') {\n  return tonwebByNetwork[network];\n}\n\nexport function oneCellFromBoc(boc: Uint8Array) {\n  return TonWeb.boc.Cell.oneFromBoc(boc);\n}\n\nexport function toBase64Address(address: AddressType, isBounceable = true) {\n  return new TonWeb.utils.Address(address).toString(true, true, isBounceable);\n}\n\nexport function toRawAddress(address: string) {\n  return new TonWeb.utils.Address(address).toString(false);\n}\n\nexport function buildTokenTransferBody(params: TokenTransferBodyParams) {\n  const {\n    queryId, tokenAmount, toAddress, responseAddress, forwardAmount,\n  } = params;\n  let forwardPayload = params.forwardPayload;\n\n  const cell = new Cell();\n  cell.bits.writeUint(JettonOpCode.Transfer, 32);\n  cell.bits.writeUint(queryId || 0, 64);\n  cell.bits.writeCoins(new BN(tokenAmount));\n  cell.bits.writeAddress(new Address(toAddress));\n  cell.bits.writeAddress(new Address(responseAddress));\n  cell.bits.writeBit(false); // null custom_payload\n  cell.bits.writeCoins(new BN(forwardAmount || '0'));\n\n  // A large comment must be placed in a separate cell\n  if (typeof forwardPayload === 'string') {\n    const buffer = Buffer.from(forwardPayload);\n    if (cell.bits.getFreeBits() < (buffer.length * 8) + 32 + 1) {\n      forwardPayload = new Cell();\n      forwardPayload.bits.writeUint(0, 32);\n      forwardPayload.bits.writeBytes(buffer);\n    }\n  }\n\n  if (!forwardPayload) {\n    cell.bits.writeBit(false);\n  } else if (typeof forwardPayload === 'string') {\n    cell.bits.writeBit(false);\n    cell.bits.writeUint(0, 32);\n    cell.bits.writeBytes(Buffer.from(forwardPayload));\n  } else {\n    cell.bits.writeBit(true);\n    cell.refs.push(forwardPayload);\n  }\n\n  return cell;\n}\n\nexport function bnToAddress(value: BN) {\n  return new Address(`0:${value.toString('hex', 64)}`).toString(true, true, true);\n}\n","import type { WalletContract } from 'tonweb/dist/types/contract/wallet/wallet-contract';\n\nimport type { ApiNetwork, ApiWalletVersion } from '../../types';\n\nimport { parseAccountId } from '../../../util/account';\nimport { compact } from '../../../util/iteratees';\nimport withCacheAsync from '../../../util/withCacheAsync';\nimport { getTonWeb, toBase64Address } from './util/tonweb';\nimport { fetchStoredAccount, fetchStoredAddress, fetchStoredPublicKey } from '../../common/accounts';\nimport { bytesToBase64, hexToBytes } from '../../common/utils';\n\nconst DEFAULT_WALLET_VERSION: ApiWalletVersion = 'v4R2';\n\nexport const isWalletInitialized = withCacheAsync(\n  async (network: ApiNetwork, walletOrAddress: WalletContract | string) => {\n    return (await getWalletInfo(network, walletOrAddress)).isInitialized;\n  },\n);\n\nexport const isActiveSmartContract = withCacheAsync(async (network: ApiNetwork, address: string) => {\n  const { isInitialized, isWallet } = await getWalletInfo(network, address);\n  return isInitialized && !isWallet;\n});\n\nexport async function publicKeyToAddress(\n  network: ApiNetwork,\n  publicKey: Uint8Array,\n  walletVersion: ApiWalletVersion = DEFAULT_WALLET_VERSION,\n) {\n  const wallet = buildWallet(network, publicKey, walletVersion);\n  const address = await wallet.getAddress();\n\n  return address.toString(true, true, true);\n}\n\nexport function buildWallet(network: ApiNetwork, publicKey: Uint8Array, walletVersion: ApiWalletVersion) {\n  const tonWeb = getTonWeb(network);\n  const WalletClass = tonWeb.wallet.all[walletVersion];\n  return new WalletClass(tonWeb.provider, { publicKey, wc: 0 });\n}\n\nexport async function getWalletInfo(network: ApiNetwork, walletOrAddress: WalletContract | string): Promise<{\n  isInitialized: boolean;\n  isWallet: boolean;\n  seqno: number;\n  balance: string;\n}> {\n  const address = typeof walletOrAddress === 'string'\n    ? walletOrAddress\n    : (await walletOrAddress.getAddress()).toString(true, true, true);\n\n  const {\n    account_state: accountState,\n    wallet: isWallet,\n    seqno,\n    balance = '0',\n  } = await getTonWeb(network).provider.getWalletInfo(address);\n  const isInitialized = accountState === 'active';\n\n  return {\n    isInitialized,\n    isWallet,\n    seqno,\n    balance,\n  };\n}\n\nexport async function getAccountBalance(accountId: string) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  return getWalletBalance(network, address);\n}\n\nexport async function getWalletBalance(\n  network: ApiNetwork, walletOrAddress: WalletContract | string,\n): Promise<string> {\n  const { balance } = await getWalletInfo(network, walletOrAddress);\n\n  return balance || '0';\n}\n\nexport async function getWalletSeqno(network: ApiNetwork, walletOrAddress: WalletContract | string): Promise<number> {\n  const { seqno } = await getWalletInfo(network, walletOrAddress);\n  return seqno || 0;\n}\n\nexport async function pickBestWallet(network: ApiNetwork, publicKey: Uint8Array) {\n  const tonWeb = getTonWeb(network);\n  const walletClasses = Object.values(tonWeb.wallet.all);\n  const allWallets = await Promise.all(walletClasses.map(async (WalletClass) => {\n    const wallet = new WalletClass(tonWeb.provider, { publicKey, wc: 0 });\n    const balance = await getWalletBalance(network, wallet);\n    if (balance === '0') {\n      return undefined;\n    }\n\n    return {\n      wallet,\n      balance: BigInt(balance),\n    };\n  }));\n  const walletsWithBalances = compact(allWallets);\n  const withBiggestBalance = walletsWithBalances.reduce<typeof walletsWithBalances[0] | undefined>((best, current) => {\n    return best && best?.balance > current.balance ? best : current;\n  }, undefined);\n\n  return withBiggestBalance?.wallet || buildWallet(network, publicKey, DEFAULT_WALLET_VERSION);\n}\n\nexport async function getWalletStateInit(accountId: string) {\n  const wallet = await pickAccountWallet(accountId);\n  const { stateInit } = await wallet!.createStateInit();\n  return bytesToBase64(await stateInit.toBoc());\n}\n\nexport async function pickWalletByAddress(network: ApiNetwork, publicKey: Uint8Array, address: string) {\n  address = toBase64Address(address);\n\n  const tonWeb = getTonWeb(network);\n  const walletClasses = tonWeb.wallet.list;\n  const allWallets = await Promise.all(walletClasses.map(async (WalletClass) => {\n    const wallet = new WalletClass(tonWeb.provider, { publicKey, wc: 0 });\n    const walletAddress = (await wallet.getAddress()).toString(true, true, true);\n\n    return {\n      wallet,\n      address: walletAddress,\n    };\n  }));\n\n  return allWallets.find((w) => w.address === address)?.wallet;\n}\n\n// TODO Cache\nexport async function pickAccountWallet(accountId: string) {\n  const { network } = parseAccountId(accountId);\n\n  const [publicKeyHex, address, account] = await Promise.all([\n    fetchStoredPublicKey(accountId),\n    fetchStoredAddress(accountId),\n    fetchStoredAccount(accountId),\n  ]);\n\n  const publicKey = hexToBytes(publicKeyHex);\n\n  if (account?.version) {\n    return buildWallet(network, publicKey, account.version);\n  }\n\n  return pickWalletByAddress(network, publicKey, address);\n}\n\nexport function resolveWalletVersion(wallet: WalletContract) {\n  const tonWeb = getTonWeb(); // The network doesn't matter\n  return Object.keys(tonWeb.wallet.all)\n    .find((version) => wallet instanceof tonWeb.wallet.all[version as keyof typeof tonWeb.wallet.all]);\n}\n","import type { NftItem } from 'tonapi-sdk-js';\n\nimport type { ApiNft, ApiNftUpdate } from '../../types';\n\nimport { parseAccountId } from '../../../util/account';\nimport { compact } from '../../../util/iteratees';\nimport { fetchAccountEvents, fetchAccountNfts, fetchNftItems } from './util/tonapiio';\nimport { toBase64Address } from './util/tonweb';\nimport { fetchStoredAddress } from '../../common/accounts';\nimport { isActiveSmartContract } from './wallet';\n\nexport async function getAccountNfts(accountId: string, offset?: number, limit?: number): Promise<ApiNft[]> {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  const rawNfts = await fetchAccountNfts(network, address, offset, limit);\n  return compact(rawNfts.map(buildNft));\n}\n\nexport function buildNft(rawNft: NftItem): ApiNft | undefined {\n  if (!rawNft.metadata) {\n    return undefined;\n  }\n\n  try {\n    const {\n      address,\n      index,\n      collection,\n      metadata: {\n        name,\n        image,\n      },\n      previews,\n      sale,\n    } = rawNft;\n\n    return {\n      index,\n      name,\n      address: toBase64Address(address),\n      image,\n      thumbnail: previews!.find((x) => x.resolution === '500x500')!.url,\n      isOnSale: Boolean(sale),\n      ...(collection && {\n        collectionAddress: toBase64Address(collection.address),\n        collectionName: collection.name,\n      }),\n    };\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport async function getNftUpdates(accountId: string, fromSec: number) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  const events = await fetchAccountEvents(network, address, fromSec);\n  fromSec = events[0]?.timestamp ?? fromSec;\n  events.reverse();\n  const updates: ApiNftUpdate[] = [];\n\n  for (const event of events) {\n    for (const action of event.actions) {\n      let to: string;\n      let nftAddress: string;\n      let rawNft: NftItem | undefined;\n      const isPurchase = !!action.nftPurchase;\n\n      if (action.nftItemTransfer) {\n        const { sender, recipient, nft: rawNftAddress } = action.nftItemTransfer;\n        if (!sender || !recipient) continue;\n        to = toBase64Address(recipient.address);\n        nftAddress = toBase64Address(rawNftAddress);\n      } else if (action.nftPurchase) {\n        const { buyer } = action.nftPurchase;\n        to = toBase64Address(buyer.address);\n        rawNft = action.nftPurchase.nft;\n        nftAddress = toBase64Address(rawNft.address);\n      } else {\n        continue;\n      }\n\n      if (to === address) {\n        if (!rawNft) {\n          [rawNft] = await fetchNftItems(network, [nftAddress]);\n        }\n        updates.push({\n          type: 'nftReceived',\n          accountId,\n          nftAddress,\n          nft: buildNft(rawNft)!,\n        });\n      } else if (!isPurchase && await isActiveSmartContract(network, to)) {\n        updates.push({\n          type: 'nftPutUpForSale',\n          accountId,\n          nftAddress,\n        });\n      } else {\n        updates.push({\n          type: 'nftSent',\n          accountId,\n          nftAddress,\n        });\n      }\n    }\n  }\n\n  return [fromSec, updates] as [number, ApiNftUpdate[]];\n}\n","import type TonWeb from 'tonweb';\n\nimport type { ApiParsedPayload } from './payload';\n\nexport type ApiWalletVersion = keyof typeof TonWeb.Wallets['all'];\n\nexport type ApiBlockchainKey = 'ton';\nexport type ApiNetwork = 'mainnet' | 'testnet';\nexport type ApiLedgerDriver = 'HID' | 'USB';\n\nexport interface AccountIdParsed {\n  id: number;\n  blockchain: ApiBlockchainKey;\n  network: ApiNetwork;\n}\n\nexport interface ApiInitArgs {\n  origin: string;\n  newestTxId?: string;\n}\n\nexport interface ApiBaseToken {\n  name: string;\n  symbol: string;\n  slug: string;\n  decimals: number;\n  minterAddress?: string;\n  image?: string;\n  isPopular?: boolean;\n  keywords?: string[];\n}\n\nexport interface ApiToken extends ApiBaseToken {\n  quote: ApiTokenPrice;\n}\n\nexport interface ApiTokenPrice {\n  price: number;\n  percentChange1h: number;\n  percentChange24h: number;\n  percentChange7d: number;\n  percentChange30d: number;\n  history24h?: ApiHistoryList;\n  history7d?: ApiHistoryList;\n  history30d?: ApiHistoryList;\n}\n\nexport type ApiKnownAddresses = Record<string, ApiAddressInfo>;\n\nexport interface ApiAddressInfo {\n  name?: string;\n  isScam?: boolean;\n}\n\nexport type ApiTxIdBySlug = Record<string, string | undefined>;\nexport type ApiTransactionType = 'stake' | 'unstake' | 'unstakeRequest' | undefined;\n\nexport interface ApiTransaction {\n  txId: string;\n  timestamp: number;\n  amount: string;\n  fromAddress: string;\n  toAddress: string;\n  comment?: string;\n  encryptedComment?: string;\n  fee: string;\n  slug: string;\n  isIncoming: boolean;\n  type?: ApiTransactionType;\n  metadata?: ApiTransactionMetadata;\n}\n\nexport interface ApiTransactionMetadata extends ApiAddressInfo {\n}\n\nexport interface ApiNft {\n  index: number;\n  name?: string;\n  address: string;\n  thumbnail: string;\n  image: string;\n  collectionName?: string;\n  collectionAddress?: string;\n  isOnSale: boolean;\n}\n\nexport type ApiHistoryList = Array<[number, number]>;\nexport type ApiTokenSimple = Omit<ApiToken, 'quote'>;\n\nexport interface ApiPoolState {\n  startOfCycle: number;\n  endOfCycle: number;\n  lastApy: number;\n  minStake: number;\n}\n\nexport interface ApiStakingState {\n  amount: number;\n  pendingDepositAmount: number;\n  isUnstakeRequested: boolean;\n}\n\nexport interface ApiBackendStakingState {\n  poolAddress: string;\n  balance: number;\n  totalProfit: number;\n  poolState: ApiPoolState;\n  profitHistory: {\n    timestamp: number;\n    profit: number;\n  }[];\n}\n\nexport interface ApiDappPermissions {\n  isAddressRequired?: boolean;\n  isPasswordRequired?: boolean;\n}\n\nexport type ApiDappRequest = {\n  origin?: string;\n  accountId?: string;\n} | {\n  origin: string;\n  accountId: string;\n};\n\nexport interface ApiDappTransaction {\n  toAddress: string;\n  amount: string;\n  rawPayload?: string;\n  payload?: ApiParsedPayload;\n  stateInit?: string;\n}\n\nexport interface ApiSubmitTransferOptions {\n  accountId: string;\n  password: string;\n  slug: string;\n  toAddress: string;\n  amount: string;\n  comment?: string;\n  fee?: string;\n  shouldEncrypt?: boolean;\n}\n\nexport enum Workchain {\n  MasterChain = -1,\n  BaseChain = 0,\n}\n\nexport const WORKCHAIN = Workchain.BaseChain;\nexport const TRANSFER_TIMEOUT_SEC = 60; // 1 min.\n\nexport interface ApiSignedTransfer {\n  base64: string;\n  seqno: number;\n  params: ApiLocalTransactionParams;\n}\n\nexport interface ApiLocalTransactionParams {\n  amount: string;\n  fromAddress: string;\n  toAddress: string;\n  comment?: string;\n  fee: string;\n  slug: string;\n  type?: ApiTransactionType;\n  encryptedComment?: string;\n}\n","// This JS library implements TON message comment encryption and decryption for Web\n// Reference C++ code - SimpleEncryptionV2 - https://github.com/ton-blockchain/ton/blob/cc0eb453cb3bf69f92693160103d33112856c056/tonlib/tonlib/keys/SimpleEncryption.cpp#L110\n// Dependencies:\n// - TonWeb 0.0.60\n// - aes-js - 3.1.2 - https://github.com/ricmoo/aes-js/releases/tag/v3.1.2 - for aes-cbc without padding\n// - noble-ed25519 - 1.7.3 - // https://github.com/paulmillr/noble-ed25519/releases/tag/1.7.3 - for getSharedKey\n\nimport type { AddressType } from 'tonweb';\nimport TonWeb from 'tonweb';\n\nimport { OpCode } from '../constants';\n\nconst ed25519 = require('../../../../lib/noble-ed25519');\nconst aesjs = require('../../../../lib/aes-js');\n\nconst { Address } = TonWeb.utils;\n\nasync function hmacSha512(key: Uint8Array, data: Uint8Array): Promise<Uint8Array> {\n  const hmacAlgo = { name: 'HMAC', hash: 'SHA-512' };\n  const hmacKey = await crypto.subtle.importKey('raw', key, hmacAlgo, false, ['sign']);\n  const signature = await crypto.subtle.sign(hmacAlgo, hmacKey, data);\n  const result = new Uint8Array(signature);\n  if (result.length !== 512 / 8) throw new Error();\n  return result;\n}\n\nfunction getAesCbcState(hash: Uint8Array): Promise<any> {\n  if (hash.length < 48) throw new Error();\n  const key = hash.slice(0, 32);\n  const iv = hash.slice(32, 32 + 16);\n\n  // Note that native crypto.subtle AES-CBC not suitable here because\n  // even if the data IS a multiple of 16 bytes, padding will still be added\n  // So we use aes-js\n\n  // eslint-disable-next-line new-cap\n  return new aesjs.ModeOfOperation.cbc(key, iv);\n}\n\nfunction getRandomPrefix(dataLength: number, minPadding: number): Uint8Array {\n  // eslint-disable-next-line no-bitwise\n  const prefixLength = ((minPadding + 15 + dataLength) & -16) - dataLength;\n  const prefix = crypto.getRandomValues(new Uint8Array(prefixLength));\n  prefix[0] = prefixLength;\n  if ((prefixLength + dataLength) % 16 !== 0) throw new Error();\n  return prefix;\n}\n\nfunction combineSecrets(a: Uint8Array, b: Uint8Array) {\n  return hmacSha512(a, b);\n}\n\nasync function encryptDataWithPrefix(data: Uint8Array, sharedSecret: Uint8Array, salt: Uint8Array) {\n  if (data.length % 16 !== 0) throw new Error();\n  const dataHash = await combineSecrets(salt, data);\n  const msgKey = dataHash.slice(0, 16);\n\n  const res = new Uint8Array(data.length + 16);\n  res.set(msgKey, 0);\n\n  const cbcStateSecret = await combineSecrets(sharedSecret, msgKey);\n  const encrypted = (await getAesCbcState(cbcStateSecret)).encrypt(data);\n  res.set(encrypted, 16);\n\n  return res;\n}\n\nasync function encryptDataImpl(data: Uint8Array, sharedSecret: Uint8Array, salt: Uint8Array) {\n  const prefix = await getRandomPrefix(data.length, 16);\n  const combined = new Uint8Array(prefix.length + data.length);\n  combined.set(prefix, 0);\n  combined.set(data, prefix.length);\n  return encryptDataWithPrefix(combined, sharedSecret, salt);\n}\n\nexport async function encryptData(\n  data: Uint8Array, myPublicKey: Uint8Array, theirPublicKey: Uint8Array, privateKey: Uint8Array, salt: Uint8Array,\n) {\n  const sharedSecret = await ed25519.getSharedSecret(privateKey, theirPublicKey);\n\n  const encrypted = await encryptDataImpl(data, sharedSecret, salt);\n  const prefixedEncrypted = new Uint8Array(myPublicKey.length + encrypted.length);\n  for (let i = 0; i < myPublicKey.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    prefixedEncrypted[i] = theirPublicKey[i] ^ myPublicKey[i];\n  }\n  prefixedEncrypted.set(encrypted, myPublicKey.length);\n  return prefixedEncrypted;\n}\n\nexport async function encryptMessageComment(\n  comment: string,\n  myPublicKey: Uint8Array,\n  theirPublicKey: Uint8Array,\n  myPrivateKey: Uint8Array,\n  senderAddress: AddressType,\n) {\n  if (!comment || !comment.length) throw new Error('empty comment');\n\n  if (myPrivateKey.length === 64) {\n    myPrivateKey = myPrivateKey.slice(0, 32); // convert nacl private key\n  }\n\n  const commentBytes = new TextEncoder().encode(comment);\n\n  const salt = new TextEncoder().encode(new Address(senderAddress).toString(true, true, true, false));\n\n  const encryptedBytes = await encryptData(commentBytes, myPublicKey, theirPublicKey, myPrivateKey, salt);\n\n  const payload = new Uint8Array(encryptedBytes.length + 4);\n\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32BE(OpCode.Encrypted);\n\n  payload.set(buffer, 0);\n  payload.set(encryptedBytes, 4);\n\n  return payload;\n}\n\nasync function doDecrypt(\n  cbcStateSecret: Uint8Array, msgKey: Uint8Array, encryptedData: Uint8Array, salt: Uint8Array,\n): Promise<Uint8Array> {\n  const decryptedData = (await getAesCbcState(cbcStateSecret)).decrypt(encryptedData);\n  const dataHash = await combineSecrets(salt, decryptedData);\n  const gotMsgKey = dataHash.slice(0, 16);\n  if (msgKey.join(',') !== gotMsgKey.join(',')) {\n    throw new Error('Failed to decrypt: hash mismatch');\n  }\n  const prefixLength = decryptedData[0];\n  if (prefixLength > decryptedData.length || prefixLength < 16) {\n    throw new Error('Failed to decrypt: invalid prefix size');\n  }\n  return decryptedData.slice(prefixLength);\n}\n\nasync function decryptDataImpl(\n  encryptedData: Uint8Array, sharedSecret: Uint8Array, salt: Uint8Array,\n): Promise<Uint8Array> {\n  if (encryptedData.length < 16) throw new Error('Failed to decrypt: data is too small');\n  if (encryptedData.length % 16 !== 0) throw new Error('Failed to decrypt: data size is not divisible by 16');\n  const msgKey = encryptedData.slice(0, 16);\n  const data = encryptedData.slice(16);\n  const cbcStateSecret = await combineSecrets(sharedSecret, msgKey);\n  const res = await doDecrypt(cbcStateSecret, msgKey, data, salt);\n  return res;\n}\n\nexport async function decryptData(data: Uint8Array, publicKey: Uint8Array, privateKey: Uint8Array, salt: Uint8Array) {\n  if (data.length < publicKey.length) {\n    throw new Error('Failed to decrypt: data is too small');\n  }\n  const theirPublicKey = new Uint8Array(publicKey.length);\n  for (let i = 0; i < publicKey.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    theirPublicKey[i] = data[i] ^ publicKey[i];\n  }\n  const sharedSecret = await ed25519.getSharedSecret(privateKey, theirPublicKey);\n\n  const decrypted = await decryptDataImpl(data.slice(publicKey.length), sharedSecret, salt);\n  return decrypted;\n}\n\nexport async function decryptMessageComment(\n  encryptedData: Uint8Array, myPublicKey: Uint8Array, myPrivateKey: Uint8Array, senderAddress: AddressType,\n) {\n  if (myPrivateKey.length === 64) {\n    myPrivateKey = myPrivateKey.slice(0, 32); // convert nacl private key\n  }\n\n  const salt = new TextEncoder().encode(new Address(senderAddress).toString(true, true, true, false));\n\n  const decryptedBytes = await decryptData(encryptedData, myPublicKey, myPrivateKey, salt);\n  return new TextDecoder().decode(decryptedBytes);\n}\n","import type { Address, DictionaryValue } from 'ton-core';\nimport {\n  BitReader, BitString, Builder, Cell, Dictionary, Slice,\n} from 'ton-core';\n\nimport type { ApiNetwork, ApiParsedPayload } from '../../../types';\nimport type { ApiTransactionExtra, JettonMetadata } from '../types';\n\nimport { pick, range } from '../../../../util/iteratees';\nimport { logDebugError } from '../../../../util/logs';\nimport { base64ToString, handleFetchErrors, sha256 } from '../../../common/utils';\nimport { JettonOpCode, NftOpCode, OpCode } from '../constants';\nimport { buildTokenSlug } from './index';\nimport { fetchNftItems } from './tonapiio';\nimport { getJettonMinterData, resolveTokenMinterAddress } from './tonweb';\n\nconst IPFS_GATEWAY_BASE_URL: string = 'https://ipfs.io/ipfs/';\n\nconst ONCHAIN_CONTENT_PREFIX = 0x00;\nconst SNAKE_PREFIX = 0x00;\n\nexport function parseJettonWalletMsgBody(body?: string) {\n  if (!body) return undefined;\n\n  try {\n    let slice = Cell.fromBase64(body).beginParse();\n    const opCode = slice.loadUint(32);\n    const queryId = slice.loadUint(64);\n\n    if (opCode === JettonOpCode.Transfer || opCode === JettonOpCode.InternalTransfer) {\n      const jettonAmount = slice.loadCoins();\n      const address = slice.loadMaybeAddress();\n      const responseAddress = slice.loadMaybeAddress();\n      let forwardAmount: bigint | undefined;\n      let forwardComment: string | undefined;\n\n      if (responseAddress) {\n        if (opCode === JettonOpCode.Transfer) {\n          slice.loadBit();\n        }\n        forwardAmount = slice.loadCoins();\n        const isSeparateCell = slice.remainingBits && slice.loadBit();\n        if (isSeparateCell && slice.remainingRefs) {\n          slice = slice.loadRef().beginParse();\n        }\n        if (slice.remainingBits > 32 && slice.loadUint(32) === 0) {\n          forwardComment = slice.loadStringTail();\n        }\n      }\n\n      return {\n        operation: JettonOpCode[opCode] as keyof typeof JettonOpCode,\n        queryId,\n        jettonAmount,\n        responseAddress,\n        address: address ? toBounceableAddress(address) : undefined,\n        forwardAmount,\n        forwardComment,\n      };\n    }\n  } catch (err) {\n    logDebugError('parseJettonWalletMsgBody', err);\n  }\n\n  return undefined;\n}\n\nexport function toBounceableAddress(address: Address) {\n  return address.toString({ urlSafe: true, bounceable: true });\n}\n\nexport function fixIpfsUrl(url: string) {\n  return url.replace('ipfs://', IPFS_GATEWAY_BASE_URL);\n}\n\nexport function fixBase64ImageData(data: string) {\n  const decodedData = base64ToString(data);\n  if (decodedData.includes('<svg')) {\n    return `data:image/svg+xml;base64,${data}`;\n  }\n  return `data:image/png;base64,${data}`;\n}\n\nconst dictSnakeBufferValue: DictionaryValue<Buffer> = {\n  parse: (slice) => {\n    const buffer = Buffer.from('');\n\n    const sliceToVal = (s: Slice, v: Buffer, isFirst: boolean) => {\n      if (isFirst && s.loadUint(8) !== SNAKE_PREFIX) {\n        throw new Error('Only snake format is supported');\n      }\n\n      v = Buffer.concat([v, s.loadBuffer(s.remainingBits / 8)]);\n      if (s.remainingRefs === 1) {\n        v = sliceToVal(s.loadRef().beginParse(), v, false);\n      }\n\n      return v;\n    };\n\n    return sliceToVal(slice.loadRef().beginParse() as any, buffer, true);\n  },\n  serialize: () => {\n    // pass\n  },\n};\n\nconst jettonOnChainMetadataSpec: {\n  [key in keyof JettonMetadata]: 'utf8' | 'ascii' | undefined;\n} = {\n  uri: 'ascii',\n  name: 'utf8',\n  description: 'utf8',\n  image: 'ascii',\n  symbol: 'utf8',\n  decimals: 'utf8',\n};\n\nexport async function getJettonMetadata(network: ApiNetwork, address: string) {\n  const { jettonContentUri, jettonContentCell } = await getJettonMinterData(network, address);\n\n  let metadata: JettonMetadata;\n\n  if (jettonContentUri) {\n    // Off-chain content\n    metadata = await fetchJettonMetadata(jettonContentUri);\n  } else {\n    // On-chain content\n    metadata = await parseJettonOnchainMetadata(await jettonContentCell.toBoc());\n    if (metadata.uri) {\n      // Semi-chain content\n      const offchainMetadata = await fetchJettonMetadata(metadata.uri);\n      metadata = { ...offchainMetadata, ...metadata };\n    }\n  }\n\n  return metadata;\n}\n\nexport async function parseJettonOnchainMetadata(array: Uint8Array): Promise<JettonMetadata> {\n  const contentCell = Cell.fromBoc(Buffer.from(array))[0];\n  const contentSlice = contentCell.beginParse();\n\n  if (contentSlice.loadUint(8) !== ONCHAIN_CONTENT_PREFIX) {\n    throw new Error('Expected onchain content marker');\n  }\n\n  const dict = contentSlice.loadDict(Dictionary.Keys.Buffer(32), dictSnakeBufferValue);\n\n  const res: { [s in keyof JettonMetadata]?: string } = {};\n\n  for (const [key, value] of Object.entries(jettonOnChainMetadataSpec)) {\n    const sha256Key = Buffer.from(await sha256(Buffer.from(key, 'ascii')));\n    const val = dict.get(sha256Key)?.toString(value);\n\n    if (val) {\n      res[key as keyof JettonMetadata] = val;\n    }\n  }\n\n  return res as JettonMetadata;\n}\n\nexport async function fetchJettonMetadata(uri: string): Promise<JettonMetadata> {\n  const metadata = await fetchJsonMetadata(uri);\n  return pick(metadata, ['name', 'description', 'symbol', 'decimals', 'image', 'image_data']);\n}\n\nasync function fetchJsonMetadata(uri: string) {\n  uri = fixIpfsUrl(uri);\n\n  const response = await fetch(uri);\n  handleFetchErrors(response);\n  return response.json();\n}\n\nexport async function parseWalletTransactionBody(\n  network: ApiNetwork, transaction: ApiTransactionExtra,\n): Promise<ApiTransactionExtra> {\n  const body = transaction.extraData?.body;\n  if (!body) return transaction;\n\n  try {\n    const slice = dataToSlice(body);\n\n    if (slice.remainingBits > 32) {\n      const parsedPayload = await parsePayloadSlice(network, transaction.toAddress, slice);\n\n      if (parsedPayload?.type === 'encrypted-comment') {\n        transaction = {\n          ...transaction,\n          encryptedComment: parsedPayload.encryptedComment,\n        };\n      }\n    }\n  } catch (err) {\n    logDebugError('parseTransactionBody', err);\n  }\n\n  return transaction;\n}\n\nexport async function parsePayloadBase64(\n  network: ApiNetwork, toAddress: string, base64: string,\n): Promise<ApiParsedPayload> {\n  const slice = dataToSlice(base64);\n  const result: ApiParsedPayload = { type: 'unknown', base64 };\n\n  if (!slice) return result;\n\n  return await parsePayloadSlice(network, toAddress, slice) ?? result;\n}\n\nexport async function parsePayloadSlice(\n  network: ApiNetwork, toAddress: string, slice: Slice,\n): Promise<ApiParsedPayload | undefined> {\n  try {\n    const opCode = slice.loadUint(32);\n\n    if (opCode === OpCode.Comment) {\n      const comment = slice.loadStringTail();\n      return { type: 'comment', comment };\n    } else if (opCode === OpCode.Encrypted) {\n      const encryptedComment = slice.loadBuffer(slice.remainingBits / 8).toString('base64');\n      return { type: 'encrypted-comment', encryptedComment };\n    }\n\n    const queryId = slice.loadUint(64).toString();\n\n    switch (opCode) {\n      case JettonOpCode.Transfer: {\n        const minterAddress = await resolveTokenMinterAddress(network, toAddress);\n        const slug = buildTokenSlug(minterAddress);\n\n        const amount = slice.loadCoins();\n        const destination = slice.loadAddress();\n        const responseDestination = slice.loadMaybeAddress();\n\n        if (!responseDestination) {\n          return {\n            type: 'transfer-tokens:non-standard',\n            queryId,\n            destination: toBounceableAddress(destination),\n            amount: amount.toString(),\n            slug,\n          };\n        }\n\n        const customPayload = slice.loadMaybeRef();\n        const forwardAmount = slice.loadCoins();\n        let forwardPayload = slice.loadMaybeRef();\n        if (!forwardPayload && slice.remainingBits) {\n          const builder = new Builder().storeBits(slice.loadBits(slice.remainingBits));\n          range(0, slice.remainingRefs).forEach(() => {\n            builder.storeRef(slice.loadRef());\n          });\n          forwardPayload = builder.endCell();\n        }\n\n        return {\n          type: 'transfer-tokens',\n          queryId,\n          amount: amount.toString(),\n          destination: toBounceableAddress(destination),\n          responseDestination: toBounceableAddress(responseDestination),\n          customPayload: customPayload?.toBoc().toString('base64'),\n          forwardAmount: forwardAmount.toString(),\n          forwardPayload: forwardPayload?.toBoc().toString('base64'),\n          slug,\n        };\n      }\n      case NftOpCode.TransferOwnership: {\n        const newOwner = slice.loadAddress();\n        const responseDestination = slice.loadAddress();\n        const customPayload = slice.loadMaybeRef();\n        const forwardAmount = slice.loadCoins();\n\n        let forwardPayload = slice.loadMaybeRef();\n        if (!forwardPayload && slice.remainingBits) {\n          const builder = new Builder().storeBits(slice.loadBits(slice.remainingBits));\n          range(0, slice.remainingRefs).forEach(() => {\n            builder.storeRef(slice.loadRef());\n          });\n          forwardPayload = builder.endCell();\n        }\n\n        const nftAddress = toAddress;\n        const [nft] = await fetchNftItems(network, [nftAddress]);\n        return {\n          type: 'transfer-nft',\n          queryId,\n          newOwner: toBounceableAddress(newOwner),\n          responseDestination: toBounceableAddress(responseDestination),\n          customPayload: customPayload?.toBoc().toString('base64'),\n          forwardAmount: forwardAmount.toString(),\n          forwardPayload: forwardPayload?.toBoc().toString('base64'),\n          nftAddress,\n          nftName: nft?.metadata?.name,\n        };\n      }\n    }\n  } catch (err) {\n    logDebugError('parsePayload', err);\n  }\n\n  return undefined;\n}\n\nfunction dataToSlice(data: string | Buffer | Uint8Array): Slice {\n  let buffer: Buffer;\n  if (typeof data === 'string') {\n    buffer = Buffer.from(data, 'base64');\n  } else if (data instanceof Buffer) {\n    buffer = data;\n  } else {\n    buffer = Buffer.from(data);\n  }\n\n  try {\n    return Cell.fromBoc(buffer)[0].beginParse();\n  } catch (err: any) {\n    if (err?.message !== 'Invalid magic') {\n      throw err;\n    }\n  }\n\n  return new Slice(new BitReader(new BitString(buffer, 0, buffer.length * 8)), []);\n}\n","import {\n  TonClient,\n  WalletContractV1R1,\n  WalletContractV1R2,\n  WalletContractV1R3,\n  WalletContractV2R1,\n  WalletContractV2R2,\n  WalletContractV3R1,\n  WalletContractV3R2,\n  WalletContractV4,\n} from 'ton';\nimport axios from 'axios';\n\nimport { WORKCHAIN } from '../../../types';\nimport type { ApiNetwork, ApiWalletVersion } from '../../../types';\n\nimport { TONHTTPAPI_MAINNET_URL, TONHTTPAPI_TESTNET_URL } from '../../../../config';\nimport { hexToBytes } from '../../../common/utils';\n\ntype TonWallet = typeof WalletContractV1R1\n| typeof WalletContractV1R2\n| typeof WalletContractV1R3\n| typeof WalletContractV2R1\n| typeof WalletContractV2R2\n| typeof WalletContractV3R1\n| typeof WalletContractV3R2\n| typeof WalletContractV4;\n\naxios.defaults.adapter = require('../../../../lib/axios-fetch-adapter').default;\n\nconst clientByNetwork: Record<ApiNetwork, TonClient> = {\n  mainnet: new TonClient({ endpoint: TONHTTPAPI_MAINNET_URL }),\n  testnet: new TonClient({ endpoint: TONHTTPAPI_TESTNET_URL }),\n};\n\nconst walletClassMap: Record<ApiWalletVersion, TonWallet | undefined> = {\n  simpleR1: WalletContractV1R1,\n  simpleR2: WalletContractV1R2,\n  simpleR3: WalletContractV1R3,\n  v2R1: WalletContractV2R1,\n  v2R2: WalletContractV2R2,\n  v3R1: WalletContractV3R1,\n  v3R2: WalletContractV3R2,\n  v4R1: undefined, // Not relevant\n  v4R2: WalletContractV4,\n};\n\nexport function getTonWalletContract(publicKeyHex: string, version: ApiWalletVersion) {\n  const walletClass = walletClassMap[version];\n  if (!walletClass) {\n    throw new Error('Unsupported wallet contract version');\n  }\n\n  const publicKey = Buffer.from(hexToBytes(publicKeyHex));\n  return walletClass.create({ workchain: WORKCHAIN, publicKey });\n}\n\nexport function getTonClient(network: ApiNetwork) {\n  return clientByNetwork[network];\n}\n","const zones = ['ton', 't.me', 'vip'];\nconst zonesRegex = {\n  ton: /^([-\\da-z]{4,126})\\.ton$/i,\n  't.me': /^([-_\\da-z]{4,126})\\.t\\.me$/i,\n  vip: /^([\\da-z]{1,24})\\.(vip|vip\\.ton|ton\\.vip)$/i,\n};\n\nfunction isDnsDomain(value: string) {\n  return Object.values(zonesRegex).some((zone) => zone.test(value));\n}\n\nfunction isVipDnsDomain(value: string) {\n  return zonesRegex.vip.test(value);\n}\n\nfunction removeZone(value: string) {\n  return Object.values(zonesRegex).map((zone) => (\n    zone.test(value) && value.match(zone)![1]\n  )).find(Boolean);\n}\n\nexport default {\n  zones,\n  zonesRegex,\n  isDnsDomain,\n  isVipDnsDomain,\n  removeZone,\n};\n","import type { ApiNetwork } from '../../types';\n\nimport dns from '../../../util/dns';\nimport { getTonWeb } from './util/tonweb';\n\nconst { DnsCollection } = require('tonweb/src/contract/dns/DnsCollection');\n\nconst VIP_DNS_COLLECTION = 'EQBWG4EBbPDv4Xj7xlPwzxd7hSyHMzwwLB5O6rY-0BBeaixS';\n\nexport async function resolveAddress(network: ApiNetwork, address: string) {\n  if (!dns.isDnsDomain(address)) {\n    return address;\n  }\n\n  const domain = address;\n  const tonweb = await getTonWeb(network);\n\n  try {\n    if (dns.isVipDnsDomain(domain)) {\n      const base = dns.removeZone(domain);\n      return (await new DnsCollection(tonweb.provider, {\n        address: VIP_DNS_COLLECTION,\n      }).resolve(base, 'wallet'))?.toString(true, true, true);\n    }\n\n    return (await tonweb.dns.getWalletAddress(domain))?.toString(true, true, true);\n  } catch (err: any) {\n    if (err.message !== 'http provider parse response error') {\n      throw err;\n    }\n    return undefined;\n  }\n}\n","import type { JettonBalance } from 'tonapi-sdk-js';\nimport TonWeb from 'tonweb';\n\nimport type {\n  ApiBaseToken, ApiNetwork, ApiToken, ApiTokenSimple,\n} from '../../types';\nimport type { ApiTransactionExtra, JettonMetadata } from './types';\n\nimport { parseAccountId } from '../../../util/account';\nimport { logDebugError } from '../../../util/logs';\nimport { buildTokenSlug } from './util';\nimport {\n  fixBase64ImageData,\n  fixIpfsUrl,\n  getJettonMetadata,\n  parseJettonWalletMsgBody,\n} from './util/metadata';\nimport { fetchJettonBalances } from './util/tonapiio';\nimport {\n  buildTokenTransferBody,\n  getTonWeb,\n  resolveTokenMinterAddress,\n  resolveTokenWalletAddress,\n  toBase64Address,\n} from './util/tonweb';\nimport { fetchStoredAddress } from '../../common/accounts';\nimport {\n  DEFAULT_DECIMALS,\n  TOKEN_TRANSFER_TON_AMOUNT,\n  TOKEN_TRANSFER_TON_FORWARD_AMOUNT,\n} from './constants';\n\nconst { JettonWallet } = TonWeb.token.jetton;\n\nexport type JettonWalletType = InstanceType<typeof JettonWallet>;\nexport type TokenBalanceParsed = {\n  slug: string;\n  balance: string;\n  token: ApiTokenSimple;\n} | undefined;\n\nconst KNOWN_TOKENS: ApiBaseToken[] = [\n  {\n    slug: 'toncoin',\n    name: 'Toncoin',\n    symbol: 'TON',\n    decimals: 9,\n  },\n];\n\nconst knownTokens = {} as Record<string, ApiToken>;\naddKnownTokens(KNOWN_TOKENS);\n\nexport async function getAccountTokenBalances(accountId: string) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  const balancesRaw: Array<JettonBalance> = await fetchJettonBalances(network, address);\n  return balancesRaw.map(parseTokenBalance).filter(Boolean);\n}\n\nfunction parseTokenBalance(balanceRaw: JettonBalance): TokenBalanceParsed {\n  if (!balanceRaw.jetton) {\n    return undefined;\n  }\n\n  try {\n    const { balance, jetton } = balanceRaw;\n    const minterAddress = toBase64Address(jetton.address);\n    const token = buildTokenByMetadata(minterAddress, jetton);\n\n    return { slug: token.slug, balance, token };\n  } catch (err) {\n    logDebugError('parseTokenBalance', err);\n    return undefined;\n  }\n}\n\nexport function parseTokenTransaction(\n  tx: ApiTransactionExtra,\n  slug: string,\n  walletAddress: string,\n): ApiTransactionExtra | undefined {\n  const { extraData } = tx;\n  if (!extraData?.body) {\n    return undefined;\n  }\n\n  const parsedData = parseJettonWalletMsgBody(extraData.body);\n  if (!parsedData) {\n    return undefined;\n  }\n\n  const {\n    operation, jettonAmount, address, forwardComment,\n  } = parsedData;\n  const isIncoming = operation === 'InternalTransfer';\n\n  return {\n    ...tx,\n    slug,\n    fromAddress: isIncoming ? (address ?? tx.fromAddress) : walletAddress,\n    toAddress: isIncoming ? walletAddress : address!,\n    amount: isIncoming ? jettonAmount.toString() : `-${jettonAmount}`,\n    comment: forwardComment,\n    isIncoming,\n  };\n}\n\nexport async function buildTokenTransfer(\n  network: ApiNetwork,\n  slug: string,\n  fromAddress: string,\n  toAddress: string,\n  amount: string,\n  comment?: string,\n) {\n  const minterAddress = resolveTokenBySlug(slug).minterAddress!;\n  const tokenWalletAddress = await resolveTokenWalletAddress(network, fromAddress, minterAddress);\n  const realMinterAddress = await resolveTokenMinterAddress(network, tokenWalletAddress);\n  if (minterAddress !== realMinterAddress) {\n    throw new Error('Invalid contract');\n  }\n\n  const tokenWallet = getTokenWallet(network, tokenWalletAddress);\n\n  const payload = buildTokenTransferBody({\n    tokenAmount: amount,\n    toAddress,\n    forwardAmount: TOKEN_TRANSFER_TON_FORWARD_AMOUNT.toString(),\n    forwardPayload: comment,\n    responseAddress: fromAddress,\n  });\n\n  return {\n    tokenWallet,\n    amount: TOKEN_TRANSFER_TON_AMOUNT.toString(),\n    toAddress: tokenWalletAddress,\n    payload,\n  };\n}\n\nexport function resolveTokenBySlug(slug: string) {\n  return knownTokens[slug]!;\n}\n\nexport function getTokenWallet(network: ApiNetwork, tokenAddress: string) {\n  return new JettonWallet(getTonWeb(network).provider, { address: tokenAddress });\n}\n\nexport async function getTokenWalletBalance(tokenWallet: JettonWalletType) {\n  return (await tokenWallet.getData()).balance.toString();\n}\n\nexport function getKnownTokens() {\n  return knownTokens;\n}\n\nexport function addKnownTokens(tokens: ApiBaseToken[]) {\n  for (const token of tokens) {\n    if (token.slug in knownTokens) continue;\n\n    knownTokens[token.slug] = {\n      ...token,\n      quote: {\n        price: 0,\n        percentChange1h: 0,\n        percentChange24h: 0,\n        percentChange7d: 0,\n        percentChange30d: 0,\n      },\n    };\n  }\n}\n\nexport async function importToken(network: ApiNetwork, address: string) {\n  const metadata = await getJettonMetadata(network, address);\n\n  return buildTokenByMetadata(address, metadata);\n}\n\nfunction buildTokenByMetadata(address: string, metadata: JettonMetadata): ApiBaseToken {\n  const {\n    name,\n    symbol,\n    image,\n    image_data: imageData,\n    decimals,\n  } = metadata;\n\n  return {\n    slug: buildTokenSlug(address),\n    name,\n    symbol,\n    decimals: decimals === undefined ? DEFAULT_DECIMALS : Number(decimals),\n    minterAddress: address,\n    image: (image && fixIpfsUrl(image)) || (imageData && fixBase64ImageData(imageData)) || undefined,\n  };\n}\n","import { Cell as TonCell } from 'ton-core';\nimport type { Method } from 'tonweb';\nimport TonWeb from 'tonweb';\nimport type { Cell } from 'tonweb/dist/types/boc/cell';\nimport type { WalletContract } from 'tonweb/dist/types/contract/wallet/wallet-contract';\n\nimport { ApiTransactionDraftError, ApiTransactionError } from '../../types';\nimport type {\n  ApiNetwork, ApiSignedTransfer, ApiTransaction, ApiTxIdBySlug,\n} from '../../types';\nimport type { ApiTransactionExtra, TonTransferParams } from './types';\n\nimport { TON_TOKEN_SLUG } from '../../../config';\nimport { parseAccountId } from '../../../util/account';\nimport { compareTransactions } from '../../../util/compareTransactions';\nimport { omit } from '../../../util/iteratees';\nimport { isValidLedgerComment } from '../../../util/ledger/utils';\nimport { logDebugError } from '../../../util/logs';\nimport { pause } from '../../../util/schedulers';\nimport { parseTxId } from './util';\nimport { decryptMessageComment, encryptMessageComment } from './util/encryption';\nimport { parseWalletTransactionBody } from './util/metadata';\nimport { getTonClient, getTonWalletContract } from './util/tonCore';\nimport {\n  fetchNewestTxId,\n  fetchTransactions,\n  getWalletPublicKey,\n  resolveTokenWalletAddress,\n  toBase64Address,\n} from './util/tonweb';\nimport { fetchStoredAccount, fetchStoredAddress, fetchStoredPublicKey } from '../../common/accounts';\nimport { getAddressInfo } from '../../common/addresses';\nimport { updateTransactionMetadata } from '../../common/helpers';\nimport { isKnownStakingPool } from '../../common/utils';\nimport { resolveAddress } from './address';\nimport { fetchKeyPair, fetchPrivateKey } from './auth';\nimport { ATTEMPTS, STAKE_COMMENT, UNSTAKE_COMMENT } from './constants';\nimport type { JettonWalletType } from './tokens';\nimport {\n  buildTokenTransfer, getTokenWalletBalance, parseTokenTransaction, resolveTokenBySlug,\n} from './tokens';\nimport {\n  getWalletBalance, getWalletInfo, isWalletInitialized, pickAccountWallet,\n} from './wallet';\n\ntype SubmitTransferResult = {\n  resolvedAddress: string;\n  amount: string;\n  seqno: number;\n  encryptedComment?: string;\n} | {\n  error: string;\n};\n\ntype SubmitMultiTransferResult = {\n  messages: (TonTransferParams & {\n    resolvedAddress: string;\n  })[];\n  amount: string;\n  seqno: number;\n} | {\n  error: string;\n};\n\nconst { Address, fromNano } = TonWeb.utils;\n\nconst DEFAULT_FEE = '10966001';\nconst DEFAULT_EXPIRE_AT_TIMEOUT_SEC = 60; // 60 sec.\nconst GET_TRANSACTIONS_LIMIT = 50;\nconst GET_TRANSACTIONS_MAX_LIMIT = 100;\nconst WAIT_SEQNO_TIMEOUT = 40000; // 40 sec.\nconst WAIT_SEQNO_PAUSE = 5000; // 5 sec.\n\nconst lastTransfers: Record<ApiNetwork, Record<string, {\n  timestamp: number;\n  seqno: number;\n}>> = {\n  mainnet: {},\n  testnet: {},\n};\n\nexport async function checkTransactionDraft(\n  accountId: string,\n  tokenSlug: string,\n  toAddress: string,\n  amount: string,\n  data?: string | Uint8Array | Cell,\n  stateInit?: Cell,\n  shouldEncrypt?: boolean,\n) {\n  const { network } = parseAccountId(accountId);\n\n  const result: {\n    error?: ApiTransactionDraftError;\n    fee?: string;\n    addressName?: string;\n    isScam?: boolean;\n  } = {};\n\n  const resolvedAddress = await resolveAddress(network, toAddress);\n  if (!resolvedAddress) {\n    result.error = ApiTransactionDraftError.DomainNotResolved;\n    return result;\n  }\n\n  toAddress = resolvedAddress;\n  if (!Address.isValid(toAddress)) {\n    result.error = ApiTransactionDraftError.InvalidToAddress;\n    return result;\n  }\n\n  const addressInfo = await getAddressInfo(toAddress);\n  result.addressName = addressInfo?.name;\n  result.isScam = addressInfo?.isScam;\n\n  if (BigInt(amount) < BigInt(0)) {\n    result.error = ApiTransactionDraftError.InvalidAmount;\n    return result;\n  }\n\n  const wallet = await pickAccountWallet(accountId);\n  if (!wallet) {\n    result.error = ApiTransactionDraftError.Unexpected;\n    return result;\n  }\n\n  if (data && typeof data === 'string' && shouldEncrypt) {\n    const toPublicKey = await getWalletPublicKey(network, toAddress);\n    if (!toPublicKey) {\n      result.error = ApiTransactionDraftError.WalletNotInitialized;\n      return result;\n    }\n  }\n\n  if (tokenSlug === TON_TOKEN_SLUG) {\n    const account = await fetchStoredAccount(accountId);\n    if (data && account?.ledger) {\n      if (typeof data !== 'string' || shouldEncrypt || !isValidLedgerComment(data)) {\n        result.error = ApiTransactionDraftError.UnsupportedHardwarePayload;\n        return result;\n      }\n    }\n  } else {\n    if (data && typeof data !== 'string') {\n      result.error = ApiTransactionDraftError.Unexpected;\n      return result;\n    }\n\n    const address = await fetchStoredAddress(accountId);\n    const tokenAmount: string = amount;\n    let tokenWallet: JettonWalletType;\n    ({\n      tokenWallet,\n      amount,\n      toAddress,\n      payload: data,\n    } = await buildTokenTransfer(network, tokenSlug, address, toAddress, amount, data));\n\n    const tokenBalance = await getTokenWalletBalance(tokenWallet!);\n    if (BigInt(tokenBalance) < BigInt(tokenAmount!)) {\n      result.error = ApiTransactionDraftError.InsufficientBalance;\n      return result;\n    }\n  }\n\n  const isInitialized = await isWalletInitialized(network, wallet);\n  result.fee = await calculateFee(isInitialized, async () => (await signTransaction(\n    network, wallet, toAddress, amount, data, stateInit,\n  )).query);\n\n  const balance = await getWalletBalance(network, wallet);\n  if (BigInt(balance) < BigInt(amount) + BigInt(result.fee)) {\n    result.error = ApiTransactionDraftError.InsufficientBalance;\n    return result;\n  }\n\n  return result;\n}\n\nexport async function submitTransfer(\n  accountId: string,\n  password: string,\n  tokenSlug: string,\n  toAddress: string,\n  amount: string,\n  data?: string | Uint8Array | Cell,\n  stateInit?: Cell,\n  shouldEncrypt?: boolean,\n): Promise<SubmitTransferResult> {\n  const { network } = parseAccountId(accountId);\n\n  try {\n    const [wallet, fromAddress, keyPair] = await Promise.all([\n      pickAccountWallet(accountId),\n      fetchStoredAddress(accountId),\n      fetchKeyPair(accountId, password),\n    ]);\n    const { publicKey, secretKey } = keyPair!;\n\n    let encryptedComment: string | undefined;\n    let resolvedAddress = await resolveAddress(network, toAddress);\n\n    if (data && typeof data === 'string' && shouldEncrypt) {\n      const toPublicKey = (await getWalletPublicKey(network, toAddress))!;\n      data = await encryptMessageComment(data, publicKey, toPublicKey, secretKey, fromAddress);\n      encryptedComment = Buffer.from(data.slice(4)).toString('base64');\n    }\n\n    if (tokenSlug !== TON_TOKEN_SLUG) {\n      if (data && typeof data !== 'string') {\n        throw new Error('Unknown error');\n      }\n\n      ({\n        amount,\n        toAddress: resolvedAddress,\n        payload: data,\n      } = await buildTokenTransfer(network, tokenSlug, fromAddress, resolvedAddress, amount, data));\n    }\n\n    // Force default bounceable address for `waitTxComplete` to work properly\n    resolvedAddress = toBase64Address(resolvedAddress);\n\n    await waitLastTransfer(network, fromAddress);\n\n    const [{ isInitialized, balance }, toWalletInfo] = await Promise.all([\n      getWalletInfo(network, wallet!),\n      getWalletInfo(network, resolvedAddress),\n    ]);\n\n    // Force non-bounceable for non-initialized recipients\n    toAddress = toWalletInfo.isInitialized\n      ? resolvedAddress\n      : toBase64Address(resolvedAddress, false);\n\n    const { seqno, query } = await signTransaction(network, wallet!, toAddress, amount, data, stateInit, secretKey);\n\n    const fee = await calculateFee(isInitialized, query);\n    if (BigInt(balance) < BigInt(amount) + BigInt(fee)) {\n      return { error: ApiTransactionError.InsufficientBalance };\n    }\n\n    await query.send();\n\n    updateLastTransfer(network, fromAddress, seqno);\n\n    return {\n      resolvedAddress, amount, seqno, encryptedComment,\n    };\n  } catch (err: any) {\n    logDebugError('submitTransfer', err);\n\n    return { error: resolveTransactionError(err) };\n  }\n}\n\nfunction resolveTransactionError(error: any): ApiTransactionError {\n  const message = typeof error === 'string' ? error : error?.message;\n  if (message?.includes('exitcode=35,')) {\n    return ApiTransactionError.IncorrectDeviceTime;\n  }\n  return ApiTransactionError.UnsuccesfulTransfer;\n}\n\nasync function signTransaction(\n  network: ApiNetwork,\n  wallet: WalletContract,\n  toAddress: string,\n  amount: string,\n  payload?: string | Uint8Array | Cell,\n  stateInit?: Cell,\n  privateKey?: Uint8Array,\n) {\n  const { seqno } = await getWalletInfo(network, wallet);\n\n  const query = wallet.methods.transfer({\n    secretKey: privateKey as any, // Workaround for wrong typing\n    toAddress,\n    amount,\n    payload,\n    seqno: seqno || 0,\n    sendMode: 3,\n    stateInit,\n  });\n\n  return { seqno, query };\n}\n\nexport async function getAccountNewestTxId(accountId: string) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  return fetchNewestTxId(network, address);\n}\n\nexport async function getAccountTransactionSlice(\n  accountId: string,\n  fromTxId?: string,\n  toTxId?: string,\n  limit?: number,\n) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  let transactions = await fetchTransactions(\n    network, address, limit ?? GET_TRANSACTIONS_LIMIT, fromTxId, toTxId,\n  );\n\n  transactions = await Promise.all(\n    transactions.map((transaction) => parseWalletTransactionBody(network, transaction)),\n  );\n\n  return transactions\n    .map(updateTransactionType)\n    .map(updateTransactionMetadata)\n    .map(omitExtraData);\n}\n\nexport async function getMergedTransactionSlice(accountId: string, lastTxIds: ApiTxIdBySlug, limit: number) {\n  // eslint-disable-next-line prefer-const\n  let { toncoin: lastTonTxId, ...tokenLastTxIds } = lastTxIds;\n  const tonTxs = await getAccountTransactionSlice(accountId, lastTonTxId, undefined, limit);\n\n  if (!tonTxs.length) {\n    return [];\n  }\n\n  lastTonTxId = tonTxs[tonTxs.length - 1].txId;\n  const lastTonTxLt = parseTxId(lastTonTxId).lt;\n\n  const results = await Promise.all(Object.entries(tokenLastTxIds).map(([slug, lastTxId]) => {\n    if (lastTxId && parseTxId(lastTxId).lt < lastTonTxLt) {\n      return [];\n    }\n\n    return getTokenTransactionSlice(accountId, slug, lastTxId, lastTonTxId, GET_TRANSACTIONS_MAX_LIMIT);\n  }));\n\n  const allTxs = [...tonTxs, ...results.flat()];\n  allTxs.sort((a, b) => compareTransactions(a, b, false));\n\n  return allTxs;\n}\n\nexport async function getTokenTransactionSlice(\n  accountId: string,\n  tokenSlug: string,\n  fromTxId?: string,\n  toTxId?: string,\n  limit?: number,\n) {\n  if (tokenSlug === TON_TOKEN_SLUG) {\n    return getAccountTransactionSlice(accountId, fromTxId, toTxId, limit);\n  }\n\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  const minterAddress = resolveTokenBySlug(tokenSlug).minterAddress!;\n  const tokenWalletAddress = await resolveTokenWalletAddress(network, address, minterAddress);\n\n  const transactions = await fetchTransactions(\n    network, tokenWalletAddress, limit ?? GET_TRANSACTIONS_LIMIT, fromTxId, toTxId,\n  );\n\n  const parsedTxs = transactions\n    .map((tx) => parseTokenTransaction(tx, tokenSlug, address))\n    .filter(Boolean)\n    .map(updateTransactionMetadata)\n    .map(omitExtraData);\n\n  return parsedTxs.filter(Boolean);\n}\n\nfunction omitExtraData(tx: ApiTransactionExtra): ApiTransaction {\n  return omit(tx, ['extraData']);\n}\n\nfunction updateTransactionType(transaction: ApiTransactionExtra) {\n  const {\n    fromAddress, toAddress, comment, amount,\n  } = transaction;\n\n  if (fromAddress && toAddress) {\n    const amountNumber = Math.abs(Number(fromNano(amount)));\n\n    if (isKnownStakingPool(fromAddress) && amountNumber > 1) {\n      transaction.type = 'unstake';\n    } else if (isKnownStakingPool(toAddress)) {\n      if (comment === STAKE_COMMENT) {\n        transaction.type = 'stake';\n      } else if (comment === UNSTAKE_COMMENT) {\n        transaction.type = 'unstakeRequest';\n      }\n    }\n  }\n\n  return transaction;\n}\n\nexport async function checkMultiTransactionDraft(accountId: string, messages: TonTransferParams[]) {\n  const { network } = parseAccountId(accountId);\n\n  const result: {\n    error?: ApiTransactionDraftError;\n    fee?: string;\n    totalAmount?: string;\n  } = {};\n\n  let totalAmount: bigint = 0n;\n\n  for (const { toAddress, amount } of messages) {\n    if (BigInt(amount) < BigInt(0)) {\n      result.error = ApiTransactionDraftError.InvalidAmount;\n      return result;\n    }\n    if (!Address.isValid(toAddress)) {\n      result.error = ApiTransactionDraftError.InvalidToAddress;\n      return result;\n    }\n    totalAmount += BigInt(amount);\n  }\n\n  const wallet = await pickAccountWallet(accountId);\n\n  if (!wallet) {\n    result.error = ApiTransactionDraftError.Unexpected;\n    return result;\n  }\n\n  const { isInitialized, balance } = await getWalletInfo(network, wallet);\n\n  result.fee = await calculateFee(isInitialized, async () => (await signMultiTransaction(\n    network, wallet, messages,\n  )).query);\n  result.totalAmount = totalAmount.toString();\n\n  if (BigInt(balance) < totalAmount + BigInt(result.fee)) {\n    result.error = ApiTransactionDraftError.InsufficientBalance;\n    return result;\n  }\n\n  return result;\n}\n\nexport async function submitMultiTransfer(\n  accountId: string,\n  password: string,\n  messages: TonTransferParams[],\n  expireAt?: number,\n): Promise<SubmitMultiTransferResult> {\n  const { network } = parseAccountId(accountId);\n\n  try {\n    const [wallet, fromAddress, privateKey] = await Promise.all([\n      pickAccountWallet(accountId),\n      fetchStoredAddress(accountId),\n      fetchPrivateKey(accountId, password),\n    ]);\n\n    let totalAmount = 0n;\n    const preparedMessages = await Promise.all(messages.map(async (message) => {\n      let { toAddress } = message;\n\n      // Force default bounceable address for `waitTxComplete` to work properly\n      const resolvedAddress = toBase64Address(toAddress);\n      toAddress = await isWalletInitialized(network, toAddress)\n        ? resolvedAddress\n        : toBase64Address(toAddress, false);\n\n      totalAmount += BigInt(message.amount);\n\n      return {\n        ...message,\n        toAddress,\n        resolvedAddress,\n      };\n    }));\n\n    await waitLastTransfer(network, fromAddress);\n\n    const { isInitialized, balance } = await getWalletInfo(network, wallet!);\n\n    const { seqno, query } = await signMultiTransaction(network, wallet!, preparedMessages, privateKey, expireAt);\n\n    const fee = await calculateFee(isInitialized, query);\n    if (BigInt(balance) < BigInt(totalAmount) + BigInt(fee)) {\n      return { error: ApiTransactionError.InsufficientBalance };\n    }\n\n    await query.send();\n\n    updateLastTransfer(network, fromAddress, seqno);\n\n    return {\n      seqno,\n      amount: totalAmount.toString(),\n      messages: preparedMessages,\n    };\n  } catch (err) {\n    logDebugError('submitMultiTransfer', err);\n    return { error: resolveTransactionError(err) };\n  }\n}\n\nasync function signMultiTransaction(\n  network: ApiNetwork,\n  wallet: WalletContract,\n  messages: TonTransferParams[],\n  privateKey?: Uint8Array,\n  expireAt?: number,\n) {\n  const { seqno } = await getWalletInfo(network, wallet);\n  if (!expireAt) {\n    expireAt = Math.round(Date.now() / 1000) + DEFAULT_EXPIRE_AT_TIMEOUT_SEC;\n  }\n\n  // TODO Uncomment after fixing types in tonweb\n  // @ts-ignore\n  const query = wallet.methods.transfers({\n    secretKey: privateKey as any,\n    seqno: seqno || 0,\n    messages,\n    sendMode: 3,\n    expireAt,\n  });\n\n  return { query, seqno };\n}\n\nfunction updateLastTransfer(network: ApiNetwork, address: string, seqno: number) {\n  lastTransfers[network][address] = {\n    timestamp: Date.now(),\n    seqno,\n  };\n}\n\nexport async function waitLastTransfer(network: ApiNetwork, address: string) {\n  const lastTransfer = lastTransfers[network][address];\n  if (!lastTransfer) return;\n\n  const { seqno, timestamp } = lastTransfer;\n  const waitUntil = timestamp + WAIT_SEQNO_TIMEOUT;\n\n  const result = await waitIncrementSeqno(network, address, seqno, waitUntil);\n  if (result) {\n    delete lastTransfers[network][address];\n  }\n}\n\nasync function waitIncrementSeqno(network: ApiNetwork, address: string, seqno: number, waitUntil?: number) {\n  if (!waitUntil) {\n    waitUntil = Date.now() + WAIT_SEQNO_TIMEOUT;\n  }\n\n  while (Date.now() < waitUntil) {\n    try {\n      const { seqno: currentSeqno } = await getWalletInfo(network, address);\n      if (currentSeqno > seqno) {\n        return true;\n      }\n\n      await pause(WAIT_SEQNO_PAUSE);\n    } catch (err) {\n      logDebugError('waitIncrementSeqno', err);\n    }\n  }\n\n  return false;\n}\n\nasync function calculateFee(isInitialized: boolean, query: Method | (() => Promise<Method>)) {\n  if (typeof query === 'function') {\n    query = await query();\n  }\n  if (isInitialized) {\n    const allFees = await query.estimateFee();\n    const fees = allFees.source_fees;\n    return String(fees.in_fwd_fee + fees.storage_fee + fees.gas_fee + fees.fwd_fee);\n  } else {\n    return DEFAULT_FEE;\n  }\n}\n\nexport async function sendSignedMessage(accountId: string, message: ApiSignedTransfer) {\n  const { network } = parseAccountId(accountId);\n  const [fromAddress, publicKey, account] = await Promise.all([\n    fetchStoredAddress(accountId),\n    fetchStoredPublicKey(accountId),\n    fetchStoredAccount(accountId),\n  ]);\n  const wallet = getTonWalletContract(publicKey!, account!.version!);\n  const client = getTonClient(network);\n  const contract = client.open(wallet);\n\n  const { base64, seqno } = message;\n  await contract.send(TonCell.fromBase64(base64));\n\n  updateLastTransfer(network, fromAddress, seqno);\n}\n\nexport async function sendSignedMessages(accountId: string, messages: ApiSignedTransfer[]) {\n  const { network } = parseAccountId(accountId);\n  const [fromAddress, publicKey, account] = await Promise.all([\n    fetchStoredAddress(accountId),\n    fetchStoredPublicKey(accountId),\n    fetchStoredAccount(accountId),\n  ]);\n  const wallet = getTonWalletContract(publicKey!, account!.version!);\n  const client = getTonClient(network);\n  const contract = client.open(wallet);\n\n  const attempts = ATTEMPTS + messages.length;\n  let index = 0;\n  let attempt = 0;\n\n  while (index < messages.length && attempt < attempts) {\n    const { base64, seqno } = messages[index];\n    try {\n      await waitLastTransfer(network, fromAddress);\n\n      await contract.send(TonCell.fromBase64(base64));\n\n      updateLastTransfer(network, fromAddress, seqno);\n\n      index++;\n    } catch (err) {\n      logDebugError('sendSignedMessages', err);\n    }\n    attempt++;\n  }\n\n  return { successNumber: index };\n}\n\nexport async function decryptComment(\n  accountId: string, encryptedComment: string, fromAddress: string, password: string,\n) {\n  const keyPair = await fetchKeyPair(accountId, password);\n  if (!keyPair) {\n    return undefined;\n  }\n\n  const { secretKey, publicKey } = keyPair;\n\n  const buffer = Buffer.from(encryptedComment, 'base64');\n\n  return decryptMessageComment(buffer, publicKey, secretKey, fromAddress);\n}\n","import TonWeb from 'tonweb';\nimport type { ContractMethods, ContractOptions } from 'tonweb/dist/types/contract/contract';\nimport type { HttpProvider } from 'tonweb/dist/types/providers/http-provider';\n\nimport { bnToAddress } from '../util/tonweb';\n\n// const { parseAddress } = require('tonweb/src/contract/token/nft/NftUtils');\n\nconst { fromNano } = TonWeb.utils;\n\ninterface NominatorPoolOptions {}\n\ninterface NominatorPoolMethods extends ContractMethods {\n  getListNominators: () => Promise<any>;\n  getPoolData: () => Promise<any>;\n  getMaxPunishment: (a: number) => Promise<number>;\n}\n\nexport class NominatorPool extends TonWeb.Contract<NominatorPoolOptions, NominatorPoolMethods> {\n  constructor(provider: HttpProvider, options: ContractOptions) {\n    options.wc = 0;\n    super(provider, options);\n\n    if (!options.address) throw new Error('required address');\n\n    this.methods.getListNominators = this.getListNominators.bind(this);\n    this.methods.getPoolData = this.getPoolData.bind(this);\n    this.methods.getMaxPunishment = this.getMaxPunishment.bind(this);\n  }\n\n  async getListNominators(): Promise<{\n    address: string;\n    amount: string;\n    pendingDepositAmount: string;\n    withdrawRequested: boolean;\n  }[]> {\n    const myAddress = await this.getAddress();\n    const result = await this.provider.call2(myAddress.toString(), 'list_nominators');\n    return (result as any[]).map((item) => {\n      return {\n        address: bnToAddress(item[0]),\n        amount: fromNano(item[1]),\n        pendingDepositAmount: fromNano(item[2]),\n        withdrawRequested: item[3].toNumber()!!,\n      };\n    });\n  }\n\n  async getPoolData() {\n    const myAddress = await this.getAddress();\n    const result = await this.provider.call2(myAddress.toString(), 'get_pool_data');\n\n    return {\n      state: result[0].toString(), // ds~load_uint(8), ;; state\n      nominatorsCount: result[1].toNumber(), // ds~load_uint(16), ;; nominators_count\n      stakeAmountSent: fromNano(result[2]), // ds~load_coins(), ;; stake_amount_sent\n      validatorAmount: fromNano(result[3]), // ds~load_coins(), ;; validator_amount\n      validatorAddress: bnToAddress(result[4]), // ds~load_uint(ADDR_SIZE()), ;; validator_address\n      validatorRewardShare: Math.round(result[5].toNumber() / 100), // ds~load_uint(16), ;; validator_reward_share\n      maxNominatorsCount: result[6].toNumber(), // ds~load_uint(16), ;; max_nominators_count\n      minValidatorStake: fromNano(result[7]), // ds~load_coins(), ;; min_validator_stake\n      minNominatorStake: fromNano(result[8]), // ds~load_coins() ;; min_nominator_stake\n      nominators: result[9].toString(), // ds~load_dict(), ;; nominators\n      withdrawRequests: result[10].toString(), // ds~load_dict(), ;; withdraw_requests\n      stakeAt: result[11].toNumber(), // ds~load_uint(32), ;; stake_at\n      // savedValidatorSetHash: result[12].toString(), // ds~load_uint(256), ;; saved_validator_set_hash\n      validatorSetChangesCount: result[13].toNumber(), // ds~load_uint(8), ;; validator_set_changes_count\n      validatorSetChangeTime: result[14].toNumber(), // ds~load_uint(32), ;; validator_set_change_time\n      stakeHeldFor: result[15].toString(), // ds~load_uint(32), ;; stake_held_for\n      configProposalVotings: result[16].toString(), // ds~load_dict() ;; config_proposal_votings\n    };\n  }\n\n  async getMaxPunishment(stake: number) {\n    const myAddress = await this.getAddress();\n    return this.provider.call2(myAddress.toString(), 'get_max_punishment', [['num', stake.toString()]]);\n  }\n}\n","import TonWeb from 'tonweb';\nimport BN from 'bn.js';\n\nimport {\n  ApiTransactionDraftError,\n} from '../../types';\nimport type {\n  ApiBackendStakingState,\n  ApiNetwork,\n  ApiStakingState,\n} from '../../types';\n\nimport { TON_TOKEN_SLUG } from '../../../config';\nimport { parseAccountId } from '../../../util/account';\nimport memoized from '../../../util/memoized';\nimport { getTonWeb } from './util/tonweb';\nimport { NominatorPool } from './contracts/NominatorPool';\nimport { fetchStoredAddress } from '../../common/accounts';\nimport { callBackendGet } from '../../common/backend';\nimport { isKnownStakingPool } from '../../common/utils';\nimport { STAKE_COMMENT, UNSTAKE_COMMENT } from './constants';\nimport { checkTransactionDraft, submitTransfer } from './transactions';\n\nconst { toNano } = TonWeb.utils;\n\nconst ONE_TON = '1000000000';\nconst UNSTAKE_AMOUNT = ONE_TON;\nconst MIN_STAKE_AMOUNT = 10001;\nconst CACHE_TTL = 60; // 1 m.\nconst DISABLE_CACHE_PERIOD = 30; // 30 s.\n\nexport const fetchStakingStateMemo = memoized(fetchBackendStakingState, CACHE_TTL);\n\nexport async function checkStakeDraft(accountId: string, amount: string) {\n  const address = await fetchStoredAddress(accountId);\n  const { poolAddress } = await fetchStakingStateMemo(address);\n\n  const result: {\n    error?: ApiTransactionDraftError;\n    fee?: string;\n  } = {};\n\n  const staked = await getStakingState(accountId);\n  if (!staked) {\n    if (new BN(amount).lt(toNano(MIN_STAKE_AMOUNT.toString()))) {\n      result.error = ApiTransactionDraftError.InvalidAmount;\n      return result;\n    }\n  }\n\n  return checkTransactionDraft(\n    accountId,\n    TON_TOKEN_SLUG,\n    poolAddress,\n    amount,\n    STAKE_COMMENT,\n  );\n}\n\nexport async function checkUnstakeDraft(accountId: string) {\n  const address = await fetchStoredAddress(accountId);\n  const { poolAddress } = await fetchStakingStateMemo(address);\n  return checkTransactionDraft(\n    accountId,\n    TON_TOKEN_SLUG,\n    poolAddress,\n    UNSTAKE_AMOUNT,\n    UNSTAKE_COMMENT,\n  );\n}\n\nexport async function submitStake(accountId: string, password: string, amount: string) {\n  const address = await fetchStoredAddress(accountId);\n  const { poolAddress } = await fetchStakingStateMemo(address);\n  const result = await submitTransfer(\n    accountId,\n    password,\n    TON_TOKEN_SLUG,\n    poolAddress,\n    amount,\n    STAKE_COMMENT,\n  );\n  onStakingChangeExpected();\n  return result;\n}\n\nexport async function submitUnstake(accountId: string, password: string) {\n  const address = await fetchStoredAddress(accountId);\n  const { poolAddress } = await fetchStakingStateMemo(address);\n  const result = await submitTransfer(\n    accountId,\n    password,\n    TON_TOKEN_SLUG,\n    poolAddress,\n    UNSTAKE_AMOUNT,\n    UNSTAKE_COMMENT,\n  );\n  onStakingChangeExpected();\n  return result;\n}\n\nfunction onStakingChangeExpected() {\n  fetchStakingStateMemo.disableCache(DISABLE_CACHE_PERIOD);\n}\n\nexport async function getStakingState(accountId: string): Promise<ApiStakingState> {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n  const contract = await getPoolContract(network, address);\n  if (network !== 'mainnet' || !contract) {\n    return {\n      amount: 0,\n      pendingDepositAmount: 0,\n      isUnstakeRequested: false,\n    };\n  }\n\n  const nominators = await contract.getListNominators();\n  const currentNominator = nominators.find((n) => n.address === address);\n  if (!currentNominator) {\n    return {\n      amount: 0,\n      pendingDepositAmount: 0,\n      isUnstakeRequested: false,\n    };\n  }\n\n  return {\n    amount: parseFloat(currentNominator.amount),\n    pendingDepositAmount: parseFloat(currentNominator.pendingDepositAmount),\n    isUnstakeRequested: currentNominator.withdrawRequested,\n  };\n}\n\nasync function getPoolContract(network: ApiNetwork, address: string) {\n  const { poolAddress } = await fetchStakingStateMemo(address);\n  return new NominatorPool(getTonWeb(network).provider, { address: poolAddress });\n}\n\nexport async function getBackendStakingState(accountId: string): Promise<ApiBackendStakingState | undefined> {\n  const { network } = parseAccountId(accountId);\n  if (network !== 'mainnet') {\n    return undefined;\n  }\n\n  const address = await fetchStoredAddress(accountId);\n  return fetchStakingStateMemo(address);\n}\n\nexport async function fetchBackendStakingState(address: string) {\n  const stakingState = await callBackendGet(`/staking-state?account=${address}`) as ApiBackendStakingState;\n\n  if (!isKnownStakingPool(stakingState.poolAddress)) {\n    throw Error('Unexpected pool address, likely a malicious activity');\n  }\n\n  return stakingState;\n}\n","import TonWeb from 'tonweb';\nimport type { Cell as CellType } from 'tonweb/dist/types/boc/cell';\n\nimport { bytesToBase64 } from '../../common/utils';\n\nconst { Cell } = TonWeb.boc;\n\nexport async function packPayloadToBoc(payload: string | Uint8Array | CellType) {\n  let payloadCell = new Cell();\n  if (payload) {\n    if (payload instanceof Cell) {\n      payloadCell = payload;\n    } else if (typeof payload === 'string') {\n      if (payload.length > 0) {\n        payloadCell.bits.writeUint(0, 32);\n        payloadCell.bits.writeString(payload);\n      }\n    } else {\n      payloadCell.bits.writeBytes(payload);\n    }\n  }\n  return bytesToBase64(await payloadCell.toBoc());\n}\n","import * as ton from './ton';\n\nexport default {\n  ton,\n};\n","// eslint-disable-next-line max-classes-per-file\nimport type { ApiAnyDisplayError } from './types';\n\nexport class ApiBaseError extends Error {\n  constructor(message?: string, public displayError?: ApiAnyDisplayError) {\n    super(message);\n    Error.captureStackTrace(this);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class ApiUserRejectsError extends ApiBaseError {\n  constructor(message: string = 'Canceled by the user') {\n    super(message);\n  }\n}\n","import generateUniqueId from '../../util/generateUniqueId';\nimport { ApiUserRejectsError } from '../errors';\n\nconst deferreds = new Map<string, Deferred>();\n\nclass Deferred<T = any> {\n  resolve!: AnyToVoidFunction;\n\n  reject!: AnyToVoidFunction;\n\n  promise = new Promise<T>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n}\n\nexport function createDappPromise(promiseId = generateUniqueId()) {\n  const deferred = new Deferred();\n\n  deferreds.set(promiseId, deferred);\n\n  const { promise } = deferred;\n\n  return { promiseId, promise };\n}\n\nexport function resolveDappPromise(promiseId: string, value?: any) {\n  const deferred = deferreds.get(promiseId);\n  if (!deferred) {\n    return;\n  }\n\n  deferred.resolve(value);\n  deferreds.delete(promiseId);\n}\n\nexport function rejectDappPromise(promiseId: string, reason: string = 'Unknown rejection reason') {\n  const deferred = deferreds.get(promiseId);\n  if (!deferred) {\n    return;\n  }\n\n  deferred.reject(new ApiUserRejectsError(reason));\n  deferreds.delete(promiseId);\n}\n\nexport function rejectAllDappPromises(message: string) {\n  Array.from(deferreds.keys()).forEach((id) => {\n    rejectDappPromise(id, message);\n  });\n}\n","import extension from '../../lib/webextension-polyfill';\n\nimport { createDappPromise, rejectAllDappPromises } from '../common/dappPromises';\nimport storage from '../storages/extension';\n\n// eslint-disable-next-line no-restricted-globals\nconst { chrome } = self;\n\nlet currentWindowId: number | undefined;\nlet readyPromise: Promise<void> | undefined;\n\nconst WINDOW_DEFAULTS = {\n  top: 120,\n  left: 20,\n  width: 368,\n  height: 750,\n};\nconst MARGIN_RIGHT = 20;\nconst WINDOW_STATE_MONITOR_INTERVAL = 3000;\n\n(function init() {\n  if (!chrome) {\n    return;\n  }\n\n  if (chrome.system) {\n    chrome.system.display.getInfo(([firstScreen]) => {\n      if (firstScreen) {\n        WINDOW_DEFAULTS.left = firstScreen.bounds.width - WINDOW_DEFAULTS.width - MARGIN_RIGHT;\n      }\n    });\n  }\n\n  extension.action.onClicked.addListener(openPopupWindow);\n\n  extension.windows.onRemoved.addListener((removedWindowId) => {\n    if (removedWindowId !== currentWindowId) {\n      return;\n    }\n\n    rejectAllDappPromises('Extension popup closed');\n\n    currentWindowId = undefined;\n    readyPromise = undefined;\n  });\n\n  setInterval(async () => {\n    const currentWindow = await extension.windows.getCurrent();\n    if (!currentWindow || currentWindow.id !== currentWindowId) {\n      return;\n    }\n\n    void storage.setItem('windowState', {\n      top: currentWindow.top,\n      left: currentWindow.left,\n      height: currentWindow.height,\n      width: currentWindow.width,\n    });\n  }, WINDOW_STATE_MONITOR_INTERVAL);\n}());\n\nexport async function openPopupWindow() {\n  if (typeof currentWindowId === 'number') {\n    await extension.windows.update(currentWindowId, { focused: true });\n    return readyPromise;\n  }\n\n  const lastWindowId = Number(await storage.getItem('windowId'));\n  if (lastWindowId) {\n    let wasWindowFound: boolean;\n    try {\n      await extension.windows.get(lastWindowId);\n      wasWindowFound = true;\n    } catch (e) {\n      wasWindowFound = false;\n    }\n\n    if (wasWindowFound) {\n      currentWindowId = lastWindowId;\n      await extension.windows.update(lastWindowId, { focused: true });\n      readyPromise = Promise.resolve();\n      return readyPromise;\n    } else {\n      await storage.removeItem('windowId');\n    }\n  }\n\n  await createWindow();\n\n  return readyPromise;\n}\n\nasync function createWindow(isRetryingWithoutLastState = false): Promise<void> {\n  const lastState = !isRetryingWithoutLastState ? await storage.getItem('windowState') : undefined;\n\n  try {\n    const window = await extension.windows.create({\n      ...WINDOW_DEFAULTS,\n      ...lastState,\n      url: 'index.html',\n      type: 'popup',\n      focused: true,\n    });\n\n    if (!window) {\n      throw new Error('Failed to create extension window');\n    }\n\n    currentWindowId = window.id;\n    readyPromise = createDappPromise('whenPopupReady').promise;\n\n    void storage.setItem('windowId', currentWindowId);\n  } catch (err) {\n    if (!isRetryingWithoutLastState) {\n      await createWindow(true);\n    } else {\n      throw err;\n    }\n  }\n}\n\nexport async function clearCache() {\n  await extension.webRequest.handlerBehaviorChanged();\n}\n","import type { ApiDappUpdate, OnApiDappUpdate } from '../types/dappUpdates';\nimport type { OnApiUpdate } from '../types';\n\nimport { getCurrentAccountId, waitLogin } from '../common/accounts';\nimport { resolveDappPromise } from '../common/dappPromises';\nimport storage from '../storages/extension';\nimport { clearCache, openPopupWindow } from './window';\n\nlet onPopupUpdate: OnApiUpdate;\n\n// Sometimes (e.g. when Dev Tools is open) dapp needs more time to subscribe to provider\nconst INIT_UPDATE_DELAY = 50;\n\nconst dappUpdaters: OnApiDappUpdate[] = [];\n\n// This method is called from `initApi` which in turn is called when popup is open\nexport function initDappMethods(_onPopupUpdate: OnApiUpdate) {\n  onPopupUpdate = _onPopupUpdate;\n  resolveDappPromise('whenPopupReady');\n}\n\nexport async function connectDapp(\n  onDappUpdate: OnApiDappUpdate,\n  onDappSendUpdates: (x: OnApiDappUpdate) => Promise<void>, // TODO Remove this when deleting the legacy provider\n) {\n  dappUpdaters.push(onDappUpdate);\n  const isTonMagicEnabled = await storage.getItem('isTonMagicEnabled');\n  const isDeeplinkHookEnabled = await storage.getItem('isDeeplinkHookEnabled');\n\n  function sendUpdates() {\n    onDappUpdate({\n      type: 'updateTonMagic',\n      isEnabled: Boolean(isTonMagicEnabled),\n    });\n\n    onDappUpdate({\n      type: 'updateDeeplinkHook',\n      isEnabled: Boolean(isDeeplinkHookEnabled),\n    });\n\n    onDappSendUpdates(onDappUpdate);\n  }\n\n  sendUpdates();\n  setTimeout(sendUpdates, INIT_UPDATE_DELAY);\n}\n\nexport function deactivateDapp(onDappUpdate: OnApiDappUpdate) {\n  const index = dappUpdaters.findIndex((updater) => updater === onDappUpdate);\n  if (index !== -1) {\n    dappUpdaters.splice(index, 1);\n  }\n}\n\nexport function updateDapps(update: ApiDappUpdate) {\n  dappUpdaters.forEach((onDappUpdate) => {\n    onDappUpdate(update);\n  });\n}\n\nexport async function prepareTransaction(params: {\n  to: string;\n  amount?: string;\n  comment?: string;\n}) {\n  await getCurrentAccountIdOrFail();\n\n  const { to: toAddress, amount, comment } = params;\n\n  await openPopupWindow();\n  await waitLogin();\n\n  onPopupUpdate({\n    type: 'prepareTransaction',\n    toAddress,\n    amount,\n    comment,\n  });\n}\n\nexport async function flushMemoryCache() {\n  await clearCache();\n}\n\nexport async function getCurrentAccountIdOrFail() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) {\n    throw new Error('The user is not authorized in the wallet');\n  }\n  return accountId;\n}\n","import type {\n  ApiDapp, ApiDappsState, ApiNetwork, OnApiUpdate,\n} from '../types';\n\nimport { buildAccountId, parseAccountId } from '../../util/account';\nimport { getAccountValue, removeAccountValue, setAccountValue } from '../common/accounts';\nimport { isUpdaterAlive, toInternalAccountId } from '../common/helpers';\nimport { updateDapps } from '../dappMethods';\nimport { storage } from '../storages';\n\ntype OnDappDisconnected = (accountId: string, origin: string) => Promise<void> | void;\n\nconst activeDappByAccountId: Record<string, string> = {};\n\nlet onUpdate: OnApiUpdate;\nlet onDappsChanged: AnyToVoidFunction = () => {};\nlet onDappDisconnected: OnDappDisconnected = () => {};\n\nexport function initDapps(\n  _onUpdate: OnApiUpdate,\n  _onDappsChanged?: AnyToVoidFunction,\n  _onDappDisconnected?: OnDappDisconnected,\n) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onUpdate = _onUpdate;\n  if (_onDappsChanged && _onDappDisconnected) {\n    onDappsChanged = _onDappsChanged;\n    onDappDisconnected = _onDappDisconnected;\n  }\n}\n\nexport function onActiveDappAccountUpdated(accountId: string) {\n  const activeDappOrigin = getActiveDapp(accountId);\n\n  onUpdate({\n    type: 'updateActiveDapp',\n    accountId,\n    origin: activeDappOrigin,\n  });\n}\n\nexport function activateDapp(accountId: string, origin: string) {\n  const oldAccountId = findActiveDappAccount(origin);\n  activeDappByAccountId[accountId] = origin;\n\n  // The method can be called in headless mode (tonConnect:reconnect)\n  if (!onUpdate || !isUpdaterAlive(onUpdate)) {\n    return;\n  }\n\n  if (oldAccountId) {\n    onUpdate({\n      type: 'updateActiveDapp',\n      accountId: oldAccountId,\n    });\n  }\n\n  onUpdate({\n    type: 'updateActiveDapp',\n    accountId,\n    origin,\n  });\n}\n\nexport function getActiveDapp(accountId: string) {\n  return activeDappByAccountId[accountId];\n}\n\nexport function deactivateDapp(origin: string) {\n  const accountId = findActiveDappAccount(origin);\n  if (!accountId) {\n    return false;\n  }\n\n  deactivateAccountDapp(accountId);\n\n  return true;\n}\n\nexport function findActiveDappAccount(origin: string) {\n  return Object.keys(activeDappByAccountId).find((acc) => origin === activeDappByAccountId[acc]);\n}\n\nexport function deactivateAccountDapp(accountId: string) {\n  const activeOrigin = activeDappByAccountId[accountId];\n  if (!activeOrigin) {\n    return false;\n  }\n\n  delete activeDappByAccountId[accountId];\n\n  onUpdate({\n    type: 'updateActiveDapp',\n    accountId,\n  });\n\n  return true;\n}\n\nexport function deactivateAllDapps() {\n  for (const [accountId, value] of Object.entries(activeDappByAccountId)) {\n    if (!value) {\n      continue;\n    }\n\n    delete activeDappByAccountId[accountId];\n\n    onUpdate({\n      type: 'updateActiveDapp',\n      accountId,\n    });\n  }\n}\n\nexport function isDappActive(accountId: string, origin: string) {\n  return activeDappByAccountId[accountId] === origin;\n}\n\nexport async function updateDapp(accountId: string, origin: string, updater: (dapp: ApiDapp) => ApiDapp) {\n  const dapp = await getDapp(accountId, origin);\n  await addDapp(accountId, updater(dapp!));\n}\n\nexport async function getDapp(accountId: string, origin: string): Promise<ApiDapp | undefined> {\n  return (await getAccountValue(accountId, 'dapps'))[origin];\n}\n\nexport async function addDapp(accountId: string, dapp: ApiDapp) {\n  const dapps = await getDappsByOrigin(accountId);\n  dapps[dapp.origin] = dapp;\n  await setAccountValue(accountId, 'dapps', dapps);\n}\n\nexport async function addDappToAccounts(dapp: ApiDapp, accountIds: string[]) {\n  const dappsByAccount = await storage.getItem('dapps') || {};\n\n  accountIds.forEach((accountId) => {\n    const internalId = toInternalAccountId(accountId);\n    const dapps = dappsByAccount[internalId] || {};\n    dapps[dapp.origin] = dapp;\n\n    dappsByAccount[internalId] = dapps;\n  });\n  await storage.setItem('dapps', dappsByAccount);\n}\n\nexport async function deleteDapp(accountId: string, origin: string, dontNotifyDapp?: boolean) {\n  const dapps = await getDappsByOrigin(accountId);\n  if (!(origin in dapps)) {\n    return false;\n  }\n\n  if (isDappActive(accountId, origin)) {\n    deactivateAccountDapp(accountId);\n  }\n\n  delete dapps[origin];\n  await setAccountValue(accountId, 'dapps', dapps);\n\n  onUpdate({\n    type: 'dappDisconnect',\n    accountId,\n    origin,\n  });\n\n  if (!dontNotifyDapp) {\n    updateDapps({\n      type: 'disconnectDapp',\n      origin,\n    });\n    await onDappDisconnected(accountId, origin);\n  }\n\n  onDappsChanged();\n\n  return true;\n}\n\nexport async function deleteAllDapps(accountId: string) {\n  deactivateAccountDapp(accountId);\n\n  const origins = Object.keys(await getDappsByOrigin(accountId));\n  await setAccountValue(accountId, 'dapps', {});\n\n  await Promise.all(origins.map(async (origin) => {\n    onUpdate({\n      type: 'dappDisconnect',\n      accountId,\n      origin,\n    });\n    await onDappDisconnected(accountId, origin);\n  }));\n\n  onDappsChanged();\n}\n\nexport async function getDapps(accountId: string): Promise<ApiDapp[]> {\n  return Object.values(await getDappsByOrigin(accountId));\n}\n\nexport async function getDappsByOrigin(accountId: string): Promise<Record<string, ApiDapp>> {\n  return await getAccountValue(accountId, 'dapps') || {};\n}\n\nexport async function isDappConnected(accountId: string, origin: string) {\n  const dapps = await getDappsByOrigin(accountId);\n\n  return Object.values(dapps).some((dapp) => dapp.origin === origin);\n}\n\nexport async function findLastConnectedAccount(network: ApiNetwork, origin: string) {\n  const dapps = await getDappsState() || {};\n\n  let connectedAt = 0;\n  let lastConnectedAccountId: string | undefined;\n\n  Object.entries(dapps).forEach(([accountId, byOrigin]) => {\n    if (!(origin in byOrigin)) return;\n\n    if ((byOrigin[origin].connectedAt) > connectedAt) {\n      connectedAt = byOrigin[origin].connectedAt;\n      lastConnectedAccountId = accountId;\n    }\n  });\n\n  if (!lastConnectedAccountId) {\n    return undefined;\n  }\n\n  return buildAccountId({ ...parseAccountId(lastConnectedAccountId), network });\n}\n\nexport function getDappsState(): Promise<ApiDappsState | undefined> {\n  return storage.getItem('dapps');\n}\n\nexport async function removeAccountDapps(accountId: string) {\n  await removeAccountValue(accountId, 'dapps');\n  onDappsChanged();\n}\n\nexport async function removeAllDapps() {\n  await storage.removeItem('dapps');\n  onDappsChanged();\n}\n\nexport function getSseLastEventId(): Promise<string | undefined> {\n  return storage.getItem('sseLastEventId');\n}\n\nexport function setSseLastEventId(lastEventId: string) {\n  return storage.setItem('sseLastEventId', lastEventId);\n}\n","import extension from '../../lib/webextension-polyfill';\n\nimport type { OnApiUpdate } from '../types';\n\nimport { PROXY_HOSTS } from '../../config';\nimport { sample } from '../../util/random';\nimport { updateDapps } from '../dappMethods';\nimport { IS_FIREFOX_EXTENSION } from '../environment';\nimport { storage } from '../storages';\n\ntype ProxyType = 'http' | 'https' | 'socks' | 'socks5';\n\ntype Proxy = {\n  type: ProxyType;\n  host: string;\n  port: string;\n};\n\ntype FirefoxProxyInfo = Proxy & {\n  username?: string;\n  password?: string;\n  proxyDNS?: boolean;\n  failoverTimeout?: number;\n  proxyAuthorizationHeader?: string;\n  connectionIsolationKey?: string;\n};\n\nconst proxies: Proxy[] = (PROXY_HOSTS ?? '').split(' ').map(((hostWithPort) => {\n  const [host, port] = hostWithPort.split(':');\n  return { type: 'http', host, port };\n}));\nconst proxy = sample(proxies);\n\n// eslint-disable-next-line max-len\nconst PROXY_PAC_SCRIPT = `function FindProxyForURL(url, host) {\n  return host.endsWith('.ton') || host.endsWith('.adnl') || host.endsWith('.bag')\n    ? 'PROXY ${proxy.host}:${proxy.port}'\n    : 'DIRECT';\n}`;\n\nlet onUpdate: OnApiUpdate;\nlet isProxyEnabled = false;\n\nexport async function initExtension(_onUpdate: OnApiUpdate) {\n  onUpdate = _onUpdate;\n\n  const isTonProxyEnabled = await storage.getItem('isTonProxyEnabled');\n  doProxy(isTonProxyEnabled);\n\n  const isDeeplinkHookEnabled = await storage.getItem('isDeeplinkHookEnabled');\n  doDeeplinkHook(isDeeplinkHookEnabled);\n}\n\nexport function setupDefaultExtensionFeatures() {\n  doDeeplinkHook(true);\n  onUpdate({\n    type: 'updateDeeplinkHookState',\n    isEnabled: Boolean(true),\n  });\n}\n\nexport async function clearExtensionFeatures() {\n  doProxy(false);\n  doMagic(false);\n  doDeeplinkHook(false);\n\n  await Promise.all([\n    storage.removeItem('isTonMagicEnabled'),\n    storage.removeItem('isTonProxyEnabled'),\n    storage.removeItem('isDeeplinkHookEnabled'),\n    storage.removeItem('dapps'),\n  ]);\n}\n\nexport function doProxy(isEnabled: boolean) {\n  if (!PROXY_HOSTS) {\n    return;\n  }\n\n  if (isProxyEnabled === isEnabled) {\n    return;\n  }\n\n  isProxyEnabled = isEnabled;\n  void storage.setItem('isTonProxyEnabled', isEnabled);\n\n  if (IS_FIREFOX_EXTENSION) {\n    if (isEnabled) {\n      extension.proxy.onRequest.addListener(firefoxOnRequest, {\n        urls: ['*://*.ton/*', '*://*.adnl/*', '*://*.bag/*'],\n      });\n    } else {\n      extension.proxy.onRequest.removeListener(firefoxOnRequest);\n    }\n  } else if (isEnabled) {\n    void extension.proxy.settings.set({\n      scope: 'regular',\n      value: {\n        mode: 'pac_script',\n        pacScript: {\n          data: PROXY_PAC_SCRIPT,\n        },\n      },\n    });\n  } else {\n    void extension.proxy.settings.clear({\n      scope: 'regular',\n    });\n  }\n}\n\nfunction firefoxOnRequest(): FirefoxProxyInfo | FirefoxProxyInfo[] {\n  return proxies;\n}\n\nexport function doMagic(isEnabled: boolean) {\n  void storage.setItem('isTonMagicEnabled', isEnabled);\n\n  updateDapps({\n    type: 'updateTonMagic',\n    isEnabled,\n  });\n}\n\nexport function doDeeplinkHook(isEnabled: boolean) {\n  void storage.setItem('isDeeplinkHookEnabled', isEnabled);\n\n  updateDapps({\n    type: 'updateDeeplinkHook',\n    isEnabled,\n  });\n}\n","export function random(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport function sample<T extends any>(arr: T[]) {\n  return arr[random(0, arr.length - 1)];\n}\n","import type { ApiBackendStakingState, OnApiUpdate } from '../types';\n\nimport { TON_TOKEN_SLUG } from '../../config';\nimport blockchains from '../blockchains';\nimport { STAKE_COMMENT, UNSTAKE_COMMENT } from '../blockchains/ton/constants';\nimport { fetchStoredAddress } from '../common/accounts';\nimport { createLocalTransaction, resolveBlockchainKey } from '../common/helpers';\n\nlet onUpdate: OnApiUpdate;\n\nexport function initStaking(_onUpdate: OnApiUpdate) {\n  onUpdate = _onUpdate;\n}\n\nexport function checkStakeDraft(accountId: string, amount: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.checkStakeDraft(accountId, amount);\n}\n\nexport function checkUnstakeDraft(accountId: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.checkUnstakeDraft(accountId);\n}\n\nexport async function submitStake(accountId: string, password: string, amount: string, fee?: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n  const fromAddress = await fetchStoredAddress(accountId);\n\n  const result = await blockchain.submitStake(accountId, password, amount);\n  if ('error' in result) {\n    return false;\n  }\n\n  const localTransaction = createLocalTransaction(onUpdate, accountId, {\n    amount: result.amount,\n    fromAddress,\n    toAddress: result.resolvedAddress,\n    comment: STAKE_COMMENT,\n    fee: fee || '0',\n    type: 'stake',\n    slug: TON_TOKEN_SLUG,\n  });\n\n  return {\n    ...result,\n    txId: localTransaction.txId,\n  };\n}\n\nexport async function submitUnstake(accountId: string, password: string, fee?: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n  const toAddress = await fetchStoredAddress(accountId);\n\n  const result = await blockchain.submitUnstake(accountId, password);\n  if ('error' in result) {\n    return false;\n  }\n\n  const localTransaction = createLocalTransaction(onUpdate, accountId, {\n    amount: result.amount,\n    fromAddress: result.resolvedAddress,\n    toAddress,\n    comment: UNSTAKE_COMMENT,\n    fee: fee || '0',\n    type: 'unstakeRequest',\n    slug: TON_TOKEN_SLUG,\n  });\n\n  return {\n    ...result,\n    txId: localTransaction.txId,\n  };\n}\n\nexport function getStakingState(accountId: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.getStakingState(accountId);\n}\n\nexport async function getBackendStakingState(accountId: string): Promise<ApiBackendStakingState | undefined> {\n  const state = await blockchains.ton.getBackendStakingState(accountId);\n  if (!state) {\n    return state;\n  }\n\n  const poolState = state.poolState;\n  return {\n    ...state,\n    poolState: {\n      ...poolState,\n      startOfCycle: poolState!.startOfCycle * 1000,\n      endOfCycle: poolState!.endOfCycle * 1000,\n    },\n  };\n}\n","import type {\n  ApiBaseToken,\n  ApiInitArgs,\n  ApiNftUpdate,\n  ApiToken,\n  ApiTokenPrice,\n  ApiTransaction,\n  ApiTxIdBySlug,\n  OnApiUpdate,\n} from '../types';\n\nimport { APP_VERSION, TON_TOKEN_SLUG } from '../../config';\nimport { compareTransactions } from '../../util/compareTransactions';\nimport { logDebugError } from '../../util/logs';\nimport { pause } from '../../util/schedulers';\nimport blockchains from '../blockchains';\nimport type { TokenBalanceParsed } from '../blockchains/ton/tokens';\nimport { addKnownTokens, getKnownTokens } from '../blockchains/ton/tokens';\nimport { tryUpdateKnownAddresses } from '../common/addresses';\nimport { callBackendGet } from '../common/backend';\nimport { isUpdaterAlive, resolveBlockchainKey } from '../common/helpers';\nimport { txCallbacks } from '../common/txCallbacks';\nimport { getBackendStakingState } from './staking';\n\ntype IsAccountActiveFn = (accountId: string) => boolean;\n\nconst POLLING_INTERVAL = 1100; // 1.1 sec\nconst BACKEND_POLLING_INTERVAL = 30000; // 30 sec\nconst LONG_BACKEND_POLLING_INTERVAL = 60000; // 1 min\n\nconst TRANSACTIONS_WAITING_PAUSE = 2000; // 2 sec\nconst FIRST_TRANSACTIONS_LIMIT = 20;\n\nconst NFT_FULL_POLLING_INTERVAL = 30000; // 30 sec\nconst NFT_FULL_UPDATE_FREQUNCY = Math.round(NFT_FULL_POLLING_INTERVAL / POLLING_INTERVAL);\n\nlet onUpdate: OnApiUpdate;\nlet isAccountActive: IsAccountActiveFn;\nlet origin: string;\n\nlet preloadEnsurePromise: Promise<any>;\nlet pricesBySlug: Record<string, ApiTokenPrice>;\n\nconst lastBalanceCache: Record<string, {\n  balance?: string;\n  tokenBalances?: Record<string, string>;\n}> = {};\n\nexport function initPolling(_onUpdate: OnApiUpdate, _isAccountActive: IsAccountActiveFn, args: ApiInitArgs) {\n  onUpdate = _onUpdate;\n  isAccountActive = _isAccountActive;\n  origin = args.origin;\n\n  preloadEnsurePromise = Promise.all([\n    tryUpdateKnownAddresses(),\n    tryUpdateTokens(_onUpdate),\n  ]);\n\n  void setupBackendPolling();\n  void setupLongBackendPolling();\n}\n\nfunction registerNewTokens(tokenBalances: TokenBalanceParsed[]) {\n  const tokens = getKnownTokens();\n  let areNewTokensFound = false;\n\n  for (const { token } of tokenBalances.filter(Boolean)) {\n    if (token.slug in tokens) continue;\n\n    areNewTokensFound = true;\n    tokens[token.slug] = {\n      ...token,\n      quote: pricesBySlug[token.slug] || {\n        price: 0.0,\n        percentChange1h: 0.0,\n        percentChange24h: 0.0,\n        percentChange7d: 0.0,\n        percentChange30d: 0.0,\n      },\n    } as ApiToken;\n  }\n\n  if (areNewTokensFound) {\n    sendUpdateTokens();\n  }\n}\n\nexport async function setupBalanceBasedPolling(accountId: string, newestTxIds: ApiTxIdBySlug = {}) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  delete lastBalanceCache[accountId];\n\n  let isFirstRun = true;\n  let nftFromSec = Math.round(Date.now() / 1000);\n  let nftUpdates: ApiNftUpdate[];\n  let i = 0;\n\n  const localOnUpdate = onUpdate;\n\n  while (isUpdaterAlive(localOnUpdate) && isAccountActive(accountId)) {\n    try {\n      const [balance, stakingState] = await Promise.all([\n        blockchain.getAccountBalance(accountId).catch(logAndRescue),\n        blockchain.getStakingState(accountId).catch(logAndRescue),\n      ]);\n      if (!isUpdaterAlive(localOnUpdate) || !isAccountActive(accountId)) return;\n\n      if (stakingState) {\n        onUpdate({\n          type: 'updateStakingState',\n          accountId,\n          stakingState,\n        });\n      }\n\n      // Full update NFTs every ~30 seconds\n      if (i % NFT_FULL_UPDATE_FREQUNCY === 0) {\n        nftFromSec = Math.round(Date.now() / 1000);\n        const nfts = await blockchain.getAccountNfts(accountId);\n        if (!isUpdaterAlive(localOnUpdate) || !isAccountActive(accountId)) return;\n\n        onUpdate({\n          type: 'updateNfts',\n          accountId,\n          nfts,\n        });\n      }\n\n      // Process balance\n      const cache = lastBalanceCache[accountId];\n      const changedTokenSlugs: string[] = [];\n\n      if (!balance || balance === cache?.balance) {\n        await pause(POLLING_INTERVAL);\n        continue;\n      }\n\n      changedTokenSlugs.push(TON_TOKEN_SLUG);\n      onUpdate({\n        type: 'updateBalance',\n        accountId,\n        slug: TON_TOKEN_SLUG,\n        balance,\n      });\n\n      lastBalanceCache[accountId] = {\n        ...lastBalanceCache[accountId],\n        balance,\n      };\n\n      // Fetch and process token balances\n      const tokenBalances = await blockchain.getAccountTokenBalances(accountId).catch(logAndRescue);\n      if (!isUpdaterAlive(localOnUpdate) || !isAccountActive(accountId)) return;\n\n      if (tokenBalances) {\n        registerNewTokens(tokenBalances);\n\n        for (const { slug, balance: tokenBalance } of tokenBalances) {\n          const cachedBalance = cache?.tokenBalances && cache.tokenBalances[slug];\n          if (cachedBalance === tokenBalance) continue;\n\n          changedTokenSlugs.push(slug);\n\n          onUpdate({\n            type: 'updateBalance',\n            accountId,\n            slug,\n            balance: tokenBalance,\n          });\n        }\n\n        lastBalanceCache[accountId] = {\n          ...lastBalanceCache[accountId],\n          tokenBalances: Object.fromEntries(tokenBalances.map(\n            ({ slug, balance: tokenBalance }) => [slug, tokenBalance],\n          )),\n        };\n      }\n\n      // Fetch transactions for tokens with a changed balance\n      if (changedTokenSlugs.length) {\n        if (!isFirstRun) {\n          await pause(TRANSACTIONS_WAITING_PAUSE);\n        }\n        const newTxIds = await processNewTokenTransactions(accountId, newestTxIds, changedTokenSlugs);\n        newestTxIds = { ...newestTxIds, ...newTxIds };\n      }\n\n      // Fetch NFT updates\n      [nftFromSec, nftUpdates] = await blockchain.getNftUpdates(accountId, nftFromSec);\n      if (!isUpdaterAlive(localOnUpdate) || !isAccountActive(accountId)) return;\n      nftUpdates.forEach(onUpdate);\n\n      isFirstRun = false;\n      i++;\n    } catch (err) {\n      logDebugError('setupBalancePolling', err);\n    }\n\n    await pause(POLLING_INTERVAL);\n  }\n}\n\nasync function processNewTokenTransactions(\n  accountId: string,\n  newestTxIds: ApiTxIdBySlug,\n  tokenSlugs: string[],\n): Promise<ApiTxIdBySlug> {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  if (!tokenSlugs.length) {\n    return {};\n  }\n\n  let allTransactions: ApiTransaction[] = [];\n\n  const entries = await Promise.all(tokenSlugs.map(async (slug) => {\n    let newestTxId = newestTxIds[slug];\n\n    const transactions = await blockchain.getTokenTransactionSlice(\n      accountId, slug, undefined, newestTxId,\n    );\n\n    if (transactions.length) {\n      newestTxId = transactions[0]!.txId;\n      allTransactions = allTransactions.concat(transactions.slice(0, FIRST_TRANSACTIONS_LIMIT));\n    }\n    return [slug, newestTxId];\n  }));\n\n  allTransactions.sort((a, b) => compareTransactions(a, b, true));\n\n  allTransactions.forEach((transaction) => {\n    txCallbacks.runCallbacks(transaction);\n  });\n\n  onUpdate({\n    type: 'newTransactions',\n    transactions: allTransactions,\n    accountId,\n  });\n\n  return Object.fromEntries(entries);\n}\n\nexport async function setupBackendPolling() {\n  const localOnUpdate = onUpdate;\n\n  while (isUpdaterAlive(localOnUpdate)) {\n    await pause(BACKEND_POLLING_INTERVAL);\n    if (!isUpdaterAlive(localOnUpdate)) return;\n\n    try {\n      await tryUpdateTokens(localOnUpdate);\n    } catch (err) {\n      logDebugError('setupBackendPolling', err);\n    }\n  }\n}\n\nexport async function setupLongBackendPolling() {\n  while (isUpdaterAlive(onUpdate)) {\n    await pause(LONG_BACKEND_POLLING_INTERVAL);\n\n    try {\n      await tryUpdateKnownAddresses();\n    } catch (err) {\n      logDebugError('setupLongBackendPolling', err);\n    }\n  }\n}\n\nexport async function tryUpdateTokens(localOnUpdate: OnApiUpdate) {\n  try {\n    const [pricesData, tokens] = await Promise.all([\n      callBackendGet('/prices', undefined, {\n        'X-App-Origin': origin,\n        'X-App-Version': APP_VERSION,\n      }) as Promise<Record<string, { slugs: string[]; quote: ApiTokenPrice }>>,\n      callBackendGet('/known-tokens') as Promise<ApiBaseToken[]>,\n    ]);\n\n    if (!isUpdaterAlive(localOnUpdate)) return;\n\n    addKnownTokens(tokens);\n\n    pricesBySlug = Object.values(pricesData).reduce((acc, { slugs, quote }) => {\n      for (const slug of slugs) {\n        acc[slug] = quote;\n      }\n      return acc;\n    }, {} as Record<string, ApiTokenPrice>);\n\n    sendUpdateTokens();\n  } catch (err) {\n    logDebugError('tryUpdateTokens', err);\n  }\n}\n\nexport function sendUpdateTokens() {\n  const tokens = getKnownTokens();\n  Object.values(tokens).forEach((token) => {\n    if (token.slug in pricesBySlug) {\n      token.quote = pricesBySlug[token.slug];\n    }\n  });\n\n  onUpdate({\n    type: 'updateTokens',\n    tokens,\n  });\n}\n\nexport async function setupBackendStakingStatePolling(accountId: string) {\n  while (isUpdaterAlive(onUpdate) && isAccountActive(accountId)) {\n    try {\n      const backendStakingState = await getBackendStakingState(accountId);\n      if (!isUpdaterAlive(onUpdate) || !isAccountActive(accountId)) return;\n\n      if (backendStakingState) {\n        onUpdate({\n          type: 'updateBackendStakingState',\n          backendStakingState,\n        });\n      }\n    } catch (err) {\n      logDebugError('setupBackendStakingStatePolling', err);\n    }\n\n    await pause(BACKEND_POLLING_INTERVAL);\n  }\n}\n\nfunction logAndRescue(err: Error) {\n  logDebugError('Polling error', err);\n\n  return undefined;\n}\n\nexport async function waitDataPreload() {\n  await preloadEnsurePromise;\n}\n","import type { ApiAccountInfo, ApiTxIdBySlug } from '../types';\n\nimport { parseAccountId } from '../../util/account';\nimport { fetchStoredAccount, loginResolve } from '../common/accounts';\nimport { waitStorageMigration } from '../common/helpers';\nimport { IS_EXTENSION } from '../environment';\nimport { storage } from '../storages';\nimport { deactivateAccountDapp, deactivateAllDapps, onActiveDappAccountUpdated } from './dapps';\nimport { clearExtensionFeatures, setupDefaultExtensionFeatures } from './extension';\nimport {\n  sendUpdateTokens,\n  setupBackendStakingStatePolling,\n  setupBalanceBasedPolling,\n} from './polling';\n\nlet activeAccountId: string | undefined;\n\nexport async function activateAccount(accountId: string, newestTxIds?: ApiTxIdBySlug) {\n  await waitStorageMigration();\n\n  const prevAccountId = activeAccountId;\n  const isFirstLogin = !prevAccountId;\n\n  activeAccountId = accountId;\n  await storage.setItem('currentAccountId', accountId);\n  loginResolve();\n\n  if (IS_EXTENSION) {\n    if (prevAccountId && parseAccountId(prevAccountId).network !== parseAccountId(accountId).network) {\n      deactivateAllDapps();\n    }\n\n    if (isFirstLogin) {\n      setupDefaultExtensionFeatures();\n    }\n\n    onActiveDappAccountUpdated(accountId);\n  }\n\n  if (isFirstLogin) {\n    sendUpdateTokens();\n  }\n\n  void setupBalanceBasedPolling(accountId, newestTxIds);\n  void setupBackendStakingStatePolling(accountId);\n}\n\nexport function deactivateAllAccounts() {\n  deactivateCurrentAccount();\n  activeAccountId = undefined;\n\n  if (IS_EXTENSION) {\n    deactivateAllDapps();\n    void clearExtensionFeatures();\n  }\n}\n\nexport function deactivateCurrentAccount() {\n  if (IS_EXTENSION) {\n    deactivateAccountDapp(activeAccountId!);\n  }\n}\n\nexport function isAccountActive(accountId: string) {\n  return activeAccountId === accountId;\n}\n\nexport function fetchAccount(accountId: string): Promise<ApiAccountInfo | undefined> {\n  return fetchStoredAccount(accountId);\n}\n\nexport function getActiveAccountId() {\n  return activeAccountId;\n}\n","import type { ApiNetwork, OnApiUpdate } from '../types';\n\nimport { parseAccountId } from '../../util/account';\nimport blockchains from '../blockchains';\nimport {\n  fetchStoredAddress,\n  fetchStoredPublicKey,\n  getMainAccountId,\n} from '../common/accounts';\nimport * as dappPromises from '../common/dappPromises';\nimport { resolveBlockchainKey } from '../common/helpers';\nimport { storage } from '../storages';\n\nlet onUpdate: OnApiUpdate;\n\nconst ton = blockchains.ton;\n\nexport async function initWallet(_onUpdate: OnApiUpdate) {\n  onUpdate = _onUpdate;\n\n  const isTonProxyEnabled = await storage.getItem('isTonProxyEnabled');\n  onUpdate({\n    type: 'updateTonProxyState',\n    isEnabled: Boolean(isTonProxyEnabled),\n  });\n\n  const isTonMagicEnabled = await storage.getItem('isTonMagicEnabled');\n  onUpdate({\n    type: 'updateTonMagicState',\n    isEnabled: Boolean(isTonMagicEnabled),\n  });\n\n  const isDeeplinkHookEnabled = await storage.getItem('isDeeplinkHookEnabled');\n  onUpdate({\n    type: 'updateDeeplinkHookState',\n    isEnabled: Boolean(isDeeplinkHookEnabled),\n  });\n}\n\nexport function getMnemonic(accountId: string, password: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.fetchMnemonic(accountId, password);\n}\n\nexport async function verifyPassword(password: string) {\n  const accountId = await getMainAccountId();\n  if (!accountId) {\n    throw new Error('The user is not authorized in the wallet');\n  }\n\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.verifyPassword(accountId, password);\n}\n\nexport function confirmDappRequest(promiseId: string, data: any) {\n  dappPromises.resolveDappPromise(promiseId, data);\n}\n\nexport function confirmDappRequestConnect(promiseId: string, data: {\n  password?: string;\n  additionalAccountIds?: string[];\n  signature?: string;\n}) {\n  dappPromises.resolveDappPromise(promiseId, data);\n}\n\nexport function cancelDappRequest(promiseId: string, reason?: string) {\n  dappPromises.rejectDappPromise(promiseId, reason);\n}\n\nexport async function getWalletSeqno(accountId: string) {\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n  return ton.getWalletSeqno(network, address);\n}\n\nexport function fetchAddress(accountId: string) {\n  return fetchStoredAddress(accountId);\n}\n\nexport function fetchPublicKey(accountId: string) {\n  return fetchStoredPublicKey(accountId);\n}\n\nexport function isWalletInitialized(network: ApiNetwork, address: string) {\n  const blockchain = blockchains.ton;\n\n  return blockchain.isWalletInitialized(network, address);\n}\n","import type { LedgerWalletInfo } from '../../util/ledger/types';\nimport type { ApiAccountInfo, ApiNetwork, ApiTxIdBySlug } from '../types';\n\nimport blockchains from '../blockchains';\nimport { getNewAccountId, removeAccountValue, setAccountValue } from '../common/accounts';\nimport { bytesToHex } from '../common/utils';\nimport { IS_DAPP_SUPPORTED } from '../environment';\nimport { storage } from '../storages';\nimport { activateAccount, deactivateAllAccounts, deactivateCurrentAccount } from './accounts';\nimport { removeAccountDapps, removeAllDapps } from './dapps';\n\nexport function generateMnemonic() {\n  return blockchains.ton.generateMnemonic();\n}\n\nexport async function createWallet(network: ApiNetwork, mnemonic: string[], password: string) {\n  const {\n    mnemonicToSeed,\n    seedToKeyPair,\n    publicKeyToAddress,\n  } = blockchains.ton;\n\n  if (!await validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic');\n  }\n\n  const seedBase64 = await mnemonicToSeed(mnemonic);\n  const { publicKey } = seedToKeyPair(seedBase64);\n  const address = await publicKeyToAddress(network, publicKey);\n\n  const accountId = await getNewAccountId(network);\n  await storeAccount(accountId, mnemonic, password, publicKey, address);\n  void activateAccount(accountId);\n\n  return {\n    accountId,\n    address,\n  };\n}\n\nexport function validateMnemonic(mnemonic: string[]) {\n  return blockchains.ton.validateMnemonic(mnemonic);\n}\n\nexport async function importMnemonic(network: ApiNetwork, mnemonic: string[], password: string) {\n  const {\n    mnemonicToSeed,\n    seedToKeyPair,\n    pickBestWallet,\n  } = blockchains.ton;\n\n  if (!await validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic');\n  }\n\n  const seedBase64 = await mnemonicToSeed(mnemonic);\n  const { publicKey } = seedToKeyPair(seedBase64);\n  const wallet = await pickBestWallet(network, publicKey);\n  const address = (await wallet.getAddress()).toString(true, true, true);\n\n  const accountId: string = await getNewAccountId(network);\n  await storeAccount(accountId, mnemonic, password, publicKey, address);\n  void activateAccount(accountId);\n\n  return {\n    accountId,\n    address,\n  };\n}\n\nexport async function importLedgerWallet(network: ApiNetwork, walletInfo: LedgerWalletInfo) {\n  const accountId: string = await getNewAccountId(network);\n  const {\n    publicKey, address, index, driver, deviceId, deviceName, version,\n  } = walletInfo;\n\n  await storeHardwareAccount(accountId, publicKey, address, {\n    version,\n    ledger: {\n      index,\n      driver,\n      deviceId,\n      deviceName,\n    },\n  });\n  void activateAccount(accountId);\n\n  return { accountId, address, walletInfo };\n}\n\nasync function storeHardwareAccount(\n  accountId: string,\n  publicKey: Uint8Array | string,\n  address: string,\n  accountInfo: ApiAccountInfo = {},\n) {\n  const publicKeyHex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n\n  await Promise.all([\n    setAccountValue(accountId, 'publicKeys', publicKeyHex),\n    setAccountValue(accountId, 'addresses', address),\n    setAccountValue(accountId, 'accounts', accountInfo),\n  ]);\n}\n\nasync function storeAccount(\n  accountId: string,\n  mnemonic: string[],\n  password: string,\n  publicKey: Uint8Array | string,\n  address: string,\n  accountInfo: ApiAccountInfo = {},\n) {\n  const mnemonicEncrypted = await blockchains.ton.encryptMnemonic(mnemonic, password);\n  const publicKeyHex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n\n  await Promise.all([\n    setAccountValue(accountId, 'mnemonicsEncrypted', mnemonicEncrypted),\n    setAccountValue(accountId, 'publicKeys', publicKeyHex),\n    setAccountValue(accountId, 'addresses', address),\n    setAccountValue(accountId, 'accounts', accountInfo),\n  ]);\n}\n\nexport async function resetAccounts() {\n  deactivateAllAccounts();\n\n  await Promise.all([\n    storage.removeItem('addresses'),\n    storage.removeItem('publicKeys'),\n    storage.removeItem('mnemonicsEncrypted'),\n    storage.removeItem('accounts'),\n    storage.removeItem('currentAccountId'),\n    IS_DAPP_SUPPORTED && removeAllDapps(),\n  ]);\n}\n\nexport async function removeAccount(accountId: string, nextAccountId: string, newestTxIds?: ApiTxIdBySlug) {\n  await Promise.all([\n    removeAccountValue(accountId, 'addresses'),\n    removeAccountValue(accountId, 'publicKeys'),\n    removeAccountValue(accountId, 'mnemonicsEncrypted'),\n    removeAccountValue(accountId, 'accounts'),\n    IS_DAPP_SUPPORTED && removeAccountDapps(accountId),\n  ]);\n\n  deactivateCurrentAccount();\n  await activateAccount(nextAccountId, newestTxIds);\n}\n","import type {\n  ApiSignedTransfer, ApiSubmitTransferOptions, ApiTxIdBySlug, OnApiUpdate,\n} from '../types';\n\nimport { parseAccountId } from '../../util/account';\nimport blockchains from '../blockchains';\nimport { fetchStoredAddress } from '../common/accounts';\nimport { createLocalTransaction, resolveBlockchainKey } from '../common/helpers';\n\nlet onUpdate: OnApiUpdate;\n\nexport function initTransactions(_onUpdate: OnApiUpdate) {\n  onUpdate = _onUpdate;\n}\n\nexport function fetchTransactions(accountId: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.getAccountTransactionSlice(accountId);\n}\n\nexport function fetchTokenTransactionSlice(accountId: string, slug: string, fromTxId?: string, limit?: number) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.getTokenTransactionSlice(accountId, slug, fromTxId, undefined, limit);\n}\n\nexport function fetchAllTransactionSlice(accountId: string, lastTxIds: ApiTxIdBySlug, limit: number) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.getMergedTransactionSlice(accountId, lastTxIds, limit);\n}\n\nexport function checkTransactionDraft(\n  accountId: string, slug: string, toAddress: string, amount: string, comment?: string, shouldEncrypt?: boolean,\n) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.checkTransactionDraft(\n    accountId, slug, toAddress, amount, comment, undefined, shouldEncrypt,\n  );\n}\n\nexport async function submitTransfer(options: ApiSubmitTransferOptions) {\n  const {\n    accountId, password, slug, toAddress, amount, comment, fee, shouldEncrypt,\n  } = options;\n\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n  const fromAddress = await fetchStoredAddress(accountId);\n  const result = await blockchain.submitTransfer(\n    accountId, password, slug, toAddress, amount, comment, undefined, shouldEncrypt,\n  );\n\n  if ('error' in result) {\n    return result;\n  }\n\n  const { encryptedComment } = result;\n  const localTransaction = createLocalTransaction(onUpdate, accountId, {\n    amount,\n    fromAddress,\n    toAddress,\n    comment: shouldEncrypt ? undefined : comment,\n    encryptedComment,\n    fee: fee || '0',\n    slug,\n  });\n\n  return {\n    ...result,\n    txId: localTransaction.txId,\n  };\n}\n\nexport async function waitLastTransfer(accountId: string) {\n  const blockchain = blockchains.ton;\n\n  const { network } = parseAccountId(accountId);\n  const address = await fetchStoredAddress(accountId);\n\n  return blockchain.waitLastTransfer(network, address);\n}\n\nexport async function sendSignedTransferMessage(accountId: string, message: ApiSignedTransfer) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  await blockchain.sendSignedMessage(accountId, message);\n\n  const localTransaction = createLocalTransaction(onUpdate, accountId, message.params);\n\n  return localTransaction.txId;\n}\n\nexport async function sendSignedTransferMessages(accountId: string, messages: ApiSignedTransfer[]) {\n  const blockchain = blockchains.ton;\n\n  const result = await blockchain.sendSignedMessages(accountId, messages);\n\n  for (let i = 0; i < result.successNumber; i++) {\n    createLocalTransaction(onUpdate, accountId, messages[i].params);\n  }\n\n  return result;\n}\n\nexport function decryptComment(accountId: string, encryptedComment: string, fromAddress: string, password: string) {\n  const blockchain = blockchains.ton;\n\n  return blockchain.decryptComment(accountId, encryptedComment, fromAddress, password);\n}\n","import blockchains from '../blockchains';\nimport { resolveBlockchainKey } from '../common/helpers';\n\nexport function fetchNfts(accountId: string) {\n  const blockchain = blockchains[resolveBlockchainKey(accountId)!];\n\n  return blockchain.getAccountNfts(accountId);\n}\n","import type { ApiNetwork } from '../types';\n\nimport { parseAccountId } from '../../util/account';\nimport blockchains from '../blockchains';\n\nexport function importToken(accountId: string, address: string) {\n  const { network, blockchain: blockchainKey } = parseAccountId(accountId);\n\n  const blockchain = blockchains[blockchainKey];\n\n  return blockchain.importToken(network, address);\n}\n\nexport function resolveTokenBySlug(slug: string) {\n  const blockchain = blockchains.ton;\n\n  return blockchain.resolveTokenBySlug(slug);\n}\n\nexport function resolveTokenWalletAddress(network: ApiNetwork, address: string, minterAddress: string) {\n  const blockchain = blockchains.ton;\n\n  return blockchain.resolveTokenWalletAddress(network, address, minterAddress);\n}\n\nexport function resolveTokenMinterAddress(network: ApiNetwork, tokenWalletAddress: string) {\n  const blockchain = blockchains.ton;\n\n  return blockchain.resolveTokenMinterAddress(network, tokenWalletAddress);\n}\n","import type { ConnectEventError, ConnectItemReply } from '@tonconnect/protocol';\n\nexport interface LocalConnectEventSuccess {\n  event: 'connect';\n  id: number;\n  payload: {\n    items: ConnectItemReply[];\n    // device: DeviceInfo; // We add it later in contentScript.js\n  };\n}\n\nexport interface TransactionPayload {\n  valid_until?: number;\n  messages: TransactionPayloadMessage[];\n}\n\nexport interface TransactionPayloadMessage {\n  address: string;\n  amount: string;\n  payload?: string;\n  stateInit?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport enum CONNECT_EVENT_ERROR_CODES {\n  UNKNOWN_ERROR = 0,\n  BAD_REQUEST_ERROR = 1,\n  MANIFEST_NOT_FOUND_ERROR = 2,\n  MANIFEST_CONTENT_ERROR = 3,\n  UNKNOWN_APP_ERROR = 100,\n  USER_REJECTS_ERROR = 300,\n  METHOD_NOT_SUPPORTED = 400,\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport enum SEND_TRANSACTION_ERROR_CODES {\n  UNKNOWN_ERROR = 0,\n  BAD_REQUEST_ERROR = 1,\n  UNKNOWN_APP_ERROR = 100,\n  USER_REJECTS_ERROR = 300,\n  METHOD_NOT_SUPPORTED = 400,\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport enum SIGN_DATA_ERROR_CODES {\n  UNKNOWN_ERROR = 0,\n  BAD_REQUEST_ERROR = 1,\n  UNKNOWN_APP_ERROR = 100,\n  USER_REJECTS_ERROR = 300,\n  METHOD_NOT_SUPPORTED = 400,\n}\n\nexport type AllErrorCodes = CONNECT_EVENT_ERROR_CODES | SEND_TRANSACTION_ERROR_CODES | SIGN_DATA_ERROR_CODES;\nexport type LocalConnectEvent = LocalConnectEventSuccess | ConnectEventError;\n\nexport interface ApiTonConnectProof {\n  timestamp: number;\n  domain: string;\n  payload: string;\n}\n","// eslint-disable-next-line max-classes-per-file\nimport { CONNECT_EVENT_ERROR_CODES } from './types';\nimport type { ApiAnyDisplayError } from '../types';\nimport type { AllErrorCodes } from './types';\n\nimport { ApiBaseError } from '../errors';\n\nexport class TonConnectError extends ApiBaseError {\n  code: number;\n\n  constructor(message: string, code: AllErrorCodes = 0, displayError?: ApiAnyDisplayError) {\n    super(message);\n    this.code = code;\n    this.displayError = displayError;\n  }\n}\n\nexport class ManifestContentError extends TonConnectError {\n  constructor(message = 'Manifest content error') {\n    super(message, CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR);\n  }\n}\n\nexport class UnknownError extends TonConnectError {\n  constructor(message = 'Unknown error') {\n    super(message, 0);\n  }\n}\n\nexport class BadRequestError extends TonConnectError {\n  constructor(message = 'Bad request', displayError?: ApiAnyDisplayError) {\n    super(message, 1, displayError);\n  }\n}\n\nexport class UnknownAppError extends TonConnectError {\n  constructor(message = 'Unknown app error') {\n    super(message, 100);\n  }\n}\n\nexport class UserRejectsError extends TonConnectError {\n  constructor(message = 'The user rejected the action') {\n    super(message, 300);\n  }\n}\n\nexport class InsufficientBalance extends BadRequestError {\n  constructor(message = 'Insufficient balance') {\n    super(message);\n  }\n}\n","export function isValidString(value: any, maxLength = 100) {\n  return typeof value === 'string' && value.length <= maxLength;\n}\n\nexport function isValidUrl(url: string) {\n  const isString = isValidString(url, 150);\n  if (!isString) return false;\n\n  try {\n    // eslint-disable-next-line no-new\n    new URL(url);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n","// eslint-disable-next-line max-classes-per-file\nimport TonWeb from 'tonweb';\nimport type {\n  ConnectEventError,\n  ConnectItemReply,\n  ConnectRequest,\n  DisconnectEvent,\n  DisconnectRpcRequest,\n  SendTransactionRpcRequest,\n  SendTransactionRpcResponse,\n  SignDataRpcRequest,\n  TonProofItem,\n  TonProofItemReplySuccess,\n} from '@tonconnect/protocol';\nimport { CHAIN } from '@tonconnect/protocol';\nimport nacl from 'tweetnacl';\n\nimport { ApiTransactionError } from '../types';\nimport { CONNECT_EVENT_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES, SIGN_DATA_ERROR_CODES } from './types';\nimport type {\n  ApiAnyDisplayError,\n  ApiDappMetadata,\n  ApiDappRequest,\n  ApiNetwork,\n  ApiSignedTransfer,\n  ApiTransactionDraftError,\n  OnApiUpdate,\n} from '../types';\nimport type {\n  ApiTonConnectProof, LocalConnectEvent, TransactionPayload, TransactionPayloadMessage,\n} from './types';\n\nimport { TON_TOKEN_SLUG } from '../../config';\nimport { parseAccountId } from '../../util/account';\nimport { isValidLedgerComment } from '../../util/ledger/utils';\nimport { logDebugError } from '../../util/logs';\nimport blockchains from '../blockchains';\nimport { parsePayloadBase64 } from '../blockchains/ton';\nimport { fetchKeyPair } from '../blockchains/ton/auth';\nimport { LEDGER_SUPPORTED_PAYLOADS } from '../blockchains/ton/constants';\nimport { toBase64Address, toRawAddress } from '../blockchains/ton/util/tonweb';\nimport {\n  fetchStoredAccount, fetchStoredAddress, fetchStoredPublicKey, getCurrentAccountId,\n} from '../common/accounts';\nimport { createDappPromise } from '../common/dappPromises';\nimport { createLocalTransaction, isUpdaterAlive } from '../common/helpers';\nimport {\n  base64ToBytes, bytesToBase64, handleFetchErrors, sha256,\n} from '../common/utils';\nimport { getCurrentAccountIdOrFail } from '../dappMethods';\nimport { openPopupWindow } from '../dappMethods/window';\nimport { IS_EXTENSION } from '../environment';\nimport * as apiErrors from '../errors';\nimport {\n  activateDapp,\n  addDapp,\n  addDappToAccounts,\n  deactivateAccountDapp,\n  deactivateDapp,\n  deleteDapp,\n  findLastConnectedAccount,\n  getDappsByOrigin,\n  isDappConnected, updateDapp,\n} from '../methods/dapps';\nimport * as errors from './errors';\nimport { BadRequestError } from './errors';\nimport { isValidString, isValidUrl } from './utils';\n\nconst { Address } = TonWeb.utils;\n\nconst ton = blockchains.ton;\n\nlet resolveInit: AnyFunction;\nconst initPromise = new Promise((resolve) => {\n  resolveInit = resolve;\n});\n\nlet onPopupUpdate: OnApiUpdate;\n\nexport function initTonConnect(_onPopupUpdate: OnApiUpdate) {\n  onPopupUpdate = _onPopupUpdate;\n  resolveInit();\n}\n\nexport async function connect(\n  request: ApiDappRequest,\n  message: ConnectRequest,\n  id: number,\n): Promise<LocalConnectEvent> {\n  try {\n    const { origin } = await validateRequest(request, true);\n    const dapp = {\n      ...await fetchDappMetadata(origin, message.manifestUrl),\n      connectedAt: Date.now(),\n    };\n\n    const addressItem = message.items.find(({ name }) => name === 'ton_addr');\n    const proofItem = message.items.find(({ name }) => name === 'ton_proof') as TonProofItem | undefined;\n    const proof = proofItem ? {\n      timestamp: Math.round(Date.now() / 1000),\n      domain: new URL(origin).host,\n      payload: proofItem.payload,\n    } : undefined;\n\n    if (!addressItem) {\n      throw new errors.BadRequestError(\"Missing 'ton_addr'\");\n    }\n\n    await openExtensionPopup();\n    const accountId = await getCurrentAccountOrFail();\n    const isConnected = await isDappConnected(accountId, origin);\n\n    let promiseResult: {\n      additionalAccountIds?: string[];\n      password?: string;\n      signature?: string;\n    } | undefined;\n\n    if (!isConnected || proof) {\n      await openExtensionPopup(true);\n\n      const { promiseId, promise } = createDappPromise();\n\n      onPopupUpdate({\n        type: 'dappConnect',\n        promiseId,\n        accountId,\n        dapp,\n        permissions: {\n          address: true,\n          proof: !!proof,\n        },\n        proof,\n      });\n\n      promiseResult = await promise;\n\n      const { additionalAccountIds } = promiseResult!;\n      if (additionalAccountIds) {\n        await addDappToAccounts(dapp, [accountId].concat(additionalAccountIds));\n      } else {\n        await addDapp(accountId, dapp);\n      }\n    }\n\n    const result = await reconnect(request, id);\n\n    if (result.event === 'connect' && proof) {\n      const address = await fetchStoredAddress(accountId);\n      const { password, signature } = promiseResult!;\n\n      let proofReplyItem: TonProofItemReplySuccess;\n      if (password) {\n        proofReplyItem = await signTonProof(accountId, password!, address, proof!);\n      } else {\n        proofReplyItem = buildTonProofReplyItem(proof, signature!);\n      }\n\n      result.payload.items.push(proofReplyItem);\n    }\n\n    return result;\n  } catch (err) {\n    logDebugError('tonConnect:connect', err);\n    return formatConnectError(id, err as Error);\n  }\n}\n\nexport async function reconnect(request: ApiDappRequest, id: number): Promise<LocalConnectEvent> {\n  try {\n    const { origin, accountId } = await validateRequest(request);\n\n    activateDapp(accountId, origin);\n    await updateDapp(accountId, origin, (dapp) => ({ ...dapp, connectedAt: Date.now() }));\n\n    const address = await fetchStoredAddress(accountId);\n    const items: ConnectItemReply[] = [\n      await buildTonAddressReplyItem(accountId, address),\n    ];\n\n    return {\n      event: 'connect',\n      id,\n      payload: { items },\n    };\n  } catch (e) {\n    logDebugError('tonConnect:reconnect', e);\n    return formatConnectError(id, e as Error);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function disconnect(request: ApiDappRequest, message: DisconnectRpcRequest): Promise<DisconnectEvent> {\n  try {\n    const { origin, accountId } = await validateRequest(request);\n\n    deactivateAccountDapp(accountId);\n    await deleteDapp(accountId, origin, true);\n  } catch (err) {\n    logDebugError('tonConnect:disconnect', err);\n  }\n  return {\n    event: 'disconnect',\n    id: Number(message.id),\n    payload: {},\n  };\n}\n\nexport async function sendTransaction(\n  request: ApiDappRequest,\n  message: SendTransactionRpcRequest,\n): Promise<SendTransactionRpcResponse> {\n  try {\n    const { origin, accountId } = await validateRequest(request);\n\n    const txPayload = JSON.parse(message.params[0]) as TransactionPayload;\n    const messages = txPayload.messages.slice(0, 3);\n    let validUntil = txPayload.valid_until;\n    if (validUntil && validUntil > 10 ** 10) {\n      // If milliseconds were passed instead of seconds\n      validUntil = Math.round(validUntil / 1000);\n    }\n\n    const { network } = parseAccountId(accountId);\n    const account = await fetchStoredAccount(accountId);\n    const isLedger = !!account?.ledger;\n\n    await openExtensionPopup(true);\n\n    const { preparedMessages, checkResult } = await checkTransactionMessages(accountId, messages);\n\n    const dapp = (await getDappsByOrigin(accountId))[origin];\n    const transactionsForRequest = await prepareTransactionForRequest(network, messages, isLedger);\n\n    const { promiseId, promise } = createDappPromise();\n\n    onPopupUpdate({\n      type: 'dappSendTransactions',\n      promiseId,\n      accountId,\n      dapp,\n      transactions: transactionsForRequest,\n      fee: checkResult.fee!,\n    });\n\n    // eslint-disable-next-line prefer-const\n    const response: string | ApiSignedTransfer[] = await promise;\n\n    if (validUntil && validUntil < (Date.now() / 1000)) {\n      throw new errors.BadRequestError('The confirmation timeout has expired');\n    }\n\n    let submitResult: any | { error: string };\n    let successNumber: number;\n\n    if (isLedger) {\n      submitResult = await ton.sendSignedMessages(accountId, response as ApiSignedTransfer[]);\n      successNumber = submitResult.successNumber;\n      if (successNumber > 0) {\n        if (successNumber < messages.length) {\n          onPopupUpdate({\n            type: 'showError',\n            error: ApiTransactionError.PartialTransactionFailure,\n          });\n        }\n      } else {\n        submitResult = { error: 'Failed transfers' };\n      }\n    } else {\n      const password = response as string;\n      successNumber = messages.length;\n      submitResult = await ton.submitMultiTransfer(accountId, password!, preparedMessages, validUntil);\n    }\n\n    if ('error' in submitResult) {\n      throw new errors.UnknownError(submitResult.error);\n    }\n\n    const fromAddress = await fetchStoredAddress(accountId);\n    const successTransactions = transactionsForRequest.slice(0, successNumber);\n\n    successTransactions.forEach(({ amount, resolvedAddress, payload }) => {\n      const comment = payload?.type === 'comment' ? payload.comment : undefined;\n      createLocalTransaction(onPopupUpdate, accountId, {\n        amount,\n        fromAddress,\n        toAddress: resolvedAddress,\n        comment,\n        fee: checkResult.fee!,\n        slug: TON_TOKEN_SLUG,\n      });\n    });\n\n    return {\n      result: 'ok',\n      id: message.id,\n    };\n  } catch (err) {\n    logDebugError('tonConnect:sendTransaction', err);\n\n    let code = SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR;\n    let errorMessage = 'Unhandled error';\n    let displayError: ApiAnyDisplayError | undefined;\n\n    if (err instanceof apiErrors.ApiUserRejectsError) {\n      code = SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR;\n      errorMessage = err.message;\n    } else if (err instanceof errors.TonConnectError) {\n      code = err.code;\n      errorMessage = err.message;\n      displayError = err.displayError;\n    } else {\n      displayError = ApiTransactionError.Unexpected;\n    }\n\n    if (onPopupUpdate && isUpdaterAlive(onPopupUpdate) && displayError) {\n      onPopupUpdate({\n        type: 'showError',\n        error: displayError,\n      });\n    }\n    return {\n      error: {\n        code,\n        message: errorMessage,\n      },\n      id: message.id,\n    };\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function signData(request: ApiDappRequest, message: SignDataRpcRequest) {\n  return {\n    error: {\n      code: SIGN_DATA_ERROR_CODES.METHOD_NOT_SUPPORTED,\n      message: 'Method not supported',\n    },\n    id: message.id,\n  };\n}\n\nasync function checkTransactionMessages(accountId: string, messages: TransactionPayloadMessage[]) {\n  const preparedMessages = messages.map((msg) => {\n    const {\n      address,\n      amount,\n      payload,\n      stateInit,\n    } = msg;\n\n    return {\n      toAddress: address,\n      amount,\n      payload: payload ? ton.oneCellFromBoc(base64ToBytes(payload)) : undefined,\n      stateInit: stateInit ? ton.oneCellFromBoc(base64ToBytes(stateInit)) : undefined,\n    };\n  });\n\n  const checkResult = await ton.checkMultiTransactionDraft(accountId, preparedMessages);\n  handleDraftError(checkResult);\n\n  return {\n    preparedMessages,\n    checkResult,\n  };\n}\n\nfunction prepareTransactionForRequest(network: ApiNetwork, messages: TransactionPayloadMessage[], isLedger: boolean) {\n  return Promise.all(messages.map(\n    async ({\n      address,\n      amount,\n      payload: rawPayload,\n      stateInit,\n    }) => {\n      const isInitialized = await ton.isWalletInitialized(network, address);\n      const resolvedAddress = toBase64Address(address);\n\n      // Force non-bounceable for non-initialized recipients\n      const toAddress = isInitialized ? resolvedAddress : toBase64Address(address, false);\n      const payload = rawPayload ? await parsePayloadBase64(network, toAddress, rawPayload) : undefined;\n\n      if (isLedger && payload) {\n        if (\n          !LEDGER_SUPPORTED_PAYLOADS.includes(payload.type)\n          || (payload.type === 'comment' && !isValidLedgerComment(payload.comment))\n          || (payload.type === 'transfer-nft' && !!payload.forwardPayload)\n        ) {\n          throw new BadRequestError('Unsupported payload', ApiTransactionError.UnsupportedHardwarePayload);\n        }\n      }\n\n      return {\n        resolvedAddress,\n        toAddress,\n        amount,\n        rawPayload,\n        payload,\n        stateInit,\n      };\n    },\n  ));\n}\n\nexport async function deactivate(request: ApiDappRequest) {\n  try {\n    const { origin } = await validateRequest(request, true);\n\n    deactivateDapp(origin);\n  } catch (err) {\n    logDebugError('tonConnect:deactivate', err);\n  }\n}\n\nfunction formatConnectError(id: number, error: Error): ConnectEventError {\n  let code = CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR;\n  let message = 'Unhandled error';\n\n  if (error instanceof apiErrors.ApiUserRejectsError) {\n    code = CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR;\n    message = error.message;\n  } else if (error instanceof errors.TonConnectError) {\n    code = error.code;\n    message = error.message;\n  }\n\n  return {\n    id,\n    event: 'connect_error',\n    payload: {\n      code,\n      message,\n    },\n  };\n}\n\nasync function buildTonAddressReplyItem(accountId: string, address: string): Promise<ConnectItemReply> {\n  const { network } = parseAccountId(accountId);\n  const [stateInit, publicKey] = await Promise.all([\n    ton.getWalletStateInit(accountId),\n    fetchStoredPublicKey(accountId),\n  ]);\n  return {\n    name: 'ton_addr',\n    address: toRawAddress(address),\n    network: network === 'mainnet' ? CHAIN.MAINNET : CHAIN.TESTNET,\n    publicKey,\n    walletStateInit: stateInit,\n  };\n}\n\nasync function signTonProof(\n  accountId: string,\n  password: string,\n  walletAddress: string,\n  proof: ApiTonConnectProof,\n): Promise<TonProofItemReplySuccess> {\n  const keyPair = await fetchKeyPair(accountId, password);\n  const { timestamp, domain, payload } = proof;\n\n  const timestampBuffer = Buffer.allocUnsafe(8);\n  timestampBuffer.writeBigInt64LE(BigInt(timestamp));\n\n  const domainBuffer = Buffer.from(domain);\n  const domainLengthBuffer = Buffer.allocUnsafe(4);\n  domainLengthBuffer.writeInt32LE(domainBuffer.byteLength);\n\n  const address = new Address(walletAddress);\n\n  const addressWorkchainBuffer = Buffer.allocUnsafe(4);\n  addressWorkchainBuffer.writeInt32BE(address.wc);\n\n  const addressBuffer = Buffer.concat([\n    addressWorkchainBuffer,\n    Buffer.from(address.hashPart),\n  ]);\n\n  const messageBuffer = Buffer.concat([\n    Buffer.from('ton-proof-item-v2/', 'utf8'),\n    addressBuffer,\n    domainLengthBuffer,\n    domainBuffer,\n    timestampBuffer,\n    Buffer.from(payload),\n  ]);\n\n  const bufferToSign = Buffer.concat([\n    Buffer.from('ffff', 'hex'),\n    Buffer.from('ton-connect', 'utf8'),\n    Buffer.from(await sha256(messageBuffer)),\n  ]);\n\n  const signature = nacl.sign.detached(\n    Buffer.from(await sha256(bufferToSign)),\n    keyPair!.secretKey,\n  );\n\n  return buildTonProofReplyItem(proof, bytesToBase64(signature));\n}\n\nfunction buildTonProofReplyItem(proof: ApiTonConnectProof, signature: string): TonProofItemReplySuccess {\n  const { timestamp, domain, payload } = proof;\n  const domainBuffer = Buffer.from(domain);\n\n  return {\n    name: 'ton_proof',\n    proof: {\n      timestamp,\n      domain: {\n        lengthBytes: domainBuffer.byteLength,\n        value: domainBuffer.toString('utf8'),\n      },\n      signature,\n      payload,\n    },\n  };\n}\n\nasync function fetchDappMetadata(origin: string, manifestUrl: string): Promise<ApiDappMetadata> {\n  try {\n    const response = await fetch(manifestUrl);\n    handleFetchErrors(response);\n\n    const { url, name, iconUrl } = await response.json();\n    if (!isValidUrl(url) || !isValidString(name) || !isValidUrl(iconUrl)) {\n      throw new Error('Invalid data');\n    }\n\n    return {\n      origin,\n      url,\n      name,\n      iconUrl,\n      manifestUrl,\n    };\n  } catch (err) {\n    logDebugError('fetchDapp', err);\n    throw new errors.ManifestContentError();\n  }\n}\n\nasync function validateRequest(request: ApiDappRequest, skipConnection = false) {\n  const { origin } = request;\n  if (!origin) {\n    throw new errors.BadRequestError('Invalid origin');\n  }\n\n  let accountId = '';\n  if (request.accountId) {\n    accountId = request.accountId;\n  } else if (!skipConnection) {\n    const { network } = parseAccountId(await getCurrentAccountIdOrFail());\n    const lastAccountId = await findLastConnectedAccount(network, origin);\n    if (!lastAccountId) {\n      throw new errors.BadRequestError('The connection is outdated, try relogin');\n    }\n    accountId = lastAccountId;\n  }\n\n  return { origin, accountId };\n}\n\nfunction handleDraftError({ error }: { error?: ApiTransactionDraftError }) {\n  if (error) {\n    onPopupUpdate({\n      type: 'showError',\n      error,\n    });\n    throw new errors.BadRequestError(error);\n  }\n}\n\nasync function openExtensionPopup(force?: boolean) {\n  if (!IS_EXTENSION || (!force && onPopupUpdate && isUpdaterAlive(onPopupUpdate))) {\n    return;\n  }\n\n  await openPopupWindow();\n  await initPromise;\n}\n\nasync function getCurrentAccountOrFail() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) {\n    throw new errors.BadRequestError('The user is not authorized in the wallet');\n  }\n  return accountId;\n}\n","import type {\n  AppRequest,\n  ConnectEvent,\n  ConnectRequest,\n  DeviceInfo,\n  RpcRequests,\n} from '@tonconnect/protocol';\nimport nacl, { randomBytes } from 'tweetnacl';\n\nimport type { ApiSseOptions } from '../types';\n\nimport { buildAccountId, parseAccountId } from '../../util/account';\nimport { extractKey } from '../../util/iteratees';\nimport { logDebug } from '../../util/logs';\nimport { waitLogin } from '../common/accounts';\nimport { bytesToHex, handleFetchErrors } from '../common/utils';\nimport { getActiveAccountId } from '../methods/accounts';\nimport {\n  getDappsState,\n  getSseLastEventId,\n  setSseLastEventId,\n  updateDapp,\n} from '../methods/dapps';\nimport * as tonConnect from './index';\n\ntype SseDapp = {\n  accountId: string;\n  origin: string;\n} & ApiSseOptions;\n\nconst BRIDGE_URL = 'https://tonconnectbridge.mytonwallet.org/bridge';\nconst TTL_SEC = 300;\nconst NONCE_SIZE = 24;\n\nlet sseEventSource: EventSource | undefined;\nlet sseDapps: SseDapp[] = [];\n\nexport async function startSseConnection(url: string, deviceInfo: DeviceInfo) {\n  await waitLogin();\n\n  const params = new URL(url).searchParams;\n\n  const version = Number(params.get('v') as string);\n  const appClientId = params.get('id') as string;\n  const request = JSON.parse(params.get('r') as string) as ConnectRequest;\n  const ret = params.get('ret') as 'back' | 'none' | string | null;\n  const origin = new URL(request.manifestUrl).origin;\n\n  logDebug('SSE Start connection:', {\n    version, appClientId, request, ret, origin,\n  });\n\n  const lastOutputId = 0;\n  const accountId = getActiveAccountId()!;\n  const result = await tonConnect.connect({ origin }, request, lastOutputId) as ConnectEvent;\n  if (result.event === 'connect') {\n    result.payload.device = deviceInfo;\n  }\n\n  const { secretKey: secretKeyArray, publicKey: publicKeyArray } = nacl.box.keyPair();\n  const secretKey = bytesToHex(secretKeyArray);\n  const clientId = bytesToHex(publicKeyArray);\n\n  await sendMessage(result, secretKey, clientId, appClientId);\n\n  if (result.event === 'connect_error') {\n    return;\n  }\n\n  await updateDapp(accountId, origin, (dapp) => ({\n    ...dapp,\n    sse: {\n      clientId,\n      appClientId,\n      secretKey,\n      lastOutputId,\n    },\n  }));\n\n  void resetupSseConnection();\n}\n\nexport async function resetupSseConnection() {\n  closeEventSource();\n\n  const [lastEventId, dappsState] = await Promise.all([\n    getSseLastEventId(),\n    getDappsState(),\n  ]);\n\n  if (!dappsState) {\n    return;\n  }\n\n  sseDapps = Object.entries(dappsState).reduce((result, [internalAccountId, dapps]) => {\n    const accountId = buildAccountId(parseAccountId(internalAccountId)); // TODO Issue #471\n    for (const dapp of Object.values(dapps)) {\n      result.push({ ...dapp.sse!, accountId, origin: dapp.origin });\n    }\n    return result;\n  }, [] as SseDapp[]);\n\n  const clientIds = extractKey(sseDapps, 'clientId');\n  if (!clientIds.length) {\n    return;\n  }\n\n  sseEventSource = openEventSource(clientIds, lastEventId);\n  sseEventSource.onmessage = async (event) => {\n    const { from, message: encryptedMessage } = JSON.parse(event.data);\n\n    const sseDapp = sseDapps.find(({ appClientId }) => appClientId === from);\n    if (!sseDapp) return;\n\n    const {\n      accountId, clientId, appClientId, secretKey, origin,\n    } = sseDapp;\n    const message = decryptMessage(encryptedMessage, appClientId, secretKey) as AppRequest<keyof RpcRequests>;\n\n    logDebug('SSE Event:', message);\n\n    await setSseLastEventId(event.lastEventId);\n\n    // @ts-ignore\n    const result = await tonConnect[message.method]({ origin, accountId }, message);\n\n    await sendMessage(result, secretKey, clientId, appClientId);\n  };\n}\n\nexport async function sendSseDisconnect(accountId: string, origin: string) {\n  const sseDapp = sseDapps.find((dapp) => dapp.origin === origin && dapp.accountId === accountId);\n  if (!sseDapp) return;\n\n  const { secretKey, clientId, appClientId } = sseDapp;\n  const lastOutputId = sseDapp.lastOutputId + 1;\n\n  await sendMessage({\n    event: 'disconnect',\n    id: lastOutputId,\n    payload: {},\n  }, secretKey, clientId, appClientId);\n}\n\nfunction sendMessage(\n  message: AnyLiteral, secretKey: string, clientId: string, toId: string, topic?: 'signTransaction' | 'signData',\n) {\n  const buffer = Buffer.from(JSON.stringify(message));\n  const encryptedMessage = encryptMessage(buffer, toId, secretKey);\n  return sendRawMessage(encryptedMessage, clientId, toId, topic);\n}\n\nasync function sendRawMessage(body: string, clientId: string, toId: string, topic?: 'signTransaction' | 'signData') {\n  const url = new URL(`${BRIDGE_URL}/message`);\n  url.searchParams.set('client_id', clientId);\n  url.searchParams.set('to', toId);\n  url.searchParams.set('ttl', TTL_SEC.toString());\n  if (topic) {\n    url.searchParams.set('topic', topic);\n  }\n\n  const response = await fetch(url, { method: 'POST', body });\n  handleFetchErrors(response);\n}\n\nfunction closeEventSource() {\n  if (!sseEventSource) return;\n\n  sseEventSource.close();\n  sseEventSource = undefined;\n}\n\nfunction openEventSource(clientIds: string[], lastEventId?: string) {\n  const url = new URL(`${BRIDGE_URL}/events`);\n  url.searchParams.set('client_id', clientIds.join(','));\n  if (lastEventId) {\n    url.searchParams.set('last_event_id', lastEventId);\n  }\n  return new EventSource(url);\n}\n\nfunction encryptMessage(message: Uint8Array, publicKey: string, secretKey: string) {\n  const nonce = randomBytes(NONCE_SIZE);\n  const encrypted = nacl.box(\n    message, nonce, Buffer.from(publicKey, 'hex'), Buffer.from(secretKey, 'hex'),\n  );\n  return Buffer.concat([nonce, encrypted]).toString('base64');\n}\n\nfunction decryptMessage(message: string, publicKey: string, secretKey: string) {\n  const fullBuffer = Buffer.from(message, 'base64');\n  const nonce = fullBuffer.subarray(0, NONCE_SIZE);\n  const encrypted = fullBuffer.subarray(NONCE_SIZE);\n  const decrypted = nacl.box.open(\n    encrypted,\n    nonce,\n    Buffer.from(publicKey, 'hex'),\n    Buffer.from(secretKey, 'hex'),\n  );\n  const jsonText = new TextDecoder('utf-8').decode(decrypted!);\n  return JSON.parse(jsonText);\n}\n","import type {\n  ApiSwapBuildRequest,\n  ApiSwapBuildResponse,\n  ApiSwapCurrency,\n  ApiSwapEstimateRequest,\n  ApiSwapEstimateResponse,\n  ApiSwapShortCurrency,\n  ApiSwapTonCurrency,\n} from '../types';\n\nimport { callBackendGet, callBackendPost } from '../common/backend';\n\nexport function swapEstimate(params: ApiSwapEstimateRequest): Promise<ApiSwapEstimateResponse> {\n  return callBackendPost('/swap/ton/estimate', params);\n}\n\nexport function swapBuild(params: ApiSwapBuildRequest): Promise<ApiSwapBuildResponse> {\n  return callBackendPost('/swap/ton/build', params);\n}\n\nexport function swapGetCurrencies(): Promise<ApiSwapCurrency[]> {\n  return callBackendGet('/swap/currencies');\n}\n\nexport function swapGetTonCurrencies(): Promise<ApiSwapTonCurrency[]> {\n  return callBackendGet('/swap/ton/tokens');\n}\n\nexport function swapGetTonPairs(): Promise<ApiSwapShortCurrency[]> {\n  return callBackendGet('/swap/ton/pairs');\n}\n","import type { OnApiDappUpdate } from '../types/dappUpdates';\nimport type { ApiSignedTransfer, OnApiUpdate } from '../types';\n\nimport { TON_TOKEN_SLUG } from '../../config';\nimport { parseAccountId } from '../../util/account';\nimport { logDebugError } from '../../util/logs';\nimport blockchains from '../blockchains';\nimport {\n  fetchStoredAccount, fetchStoredAddress, fetchStoredPublicKey, getCurrentAccountId, waitLogin,\n} from '../common/accounts';\nimport { createDappPromise } from '../common/dappPromises';\nimport { createLocalTransaction } from '../common/helpers';\nimport { base64ToBytes, hexToBytes } from '../common/utils';\nimport { getCurrentAccountIdOrFail } from './index';\nimport { openPopupWindow } from './window';\n\nconst ton = blockchains.ton;\nlet onPopupUpdate: OnApiUpdate;\n\nexport function initLegacyDappMethods(_onPopupUpdate: OnApiUpdate) {\n  onPopupUpdate = _onPopupUpdate;\n}\n\nexport async function onDappSendUpdates(onDappUpdate: OnApiDappUpdate) {\n  const accounts = await requestAccounts();\n\n  onDappUpdate({\n    type: 'updateAccounts',\n    accounts,\n  });\n}\n\nexport async function getBalance() {\n  const accountId = await getCurrentAccountIdOrFail();\n\n  return ton.getAccountBalance(accountId);\n}\n\nexport async function requestAccounts() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) {\n    return [];\n  }\n\n  const address = await fetchStoredAddress(accountId);\n  return [address];\n}\n\nexport async function requestWallets() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) {\n    return [];\n  }\n\n  const [address, publicKey, wallet] = await Promise.all([\n    fetchStoredAddress(accountId),\n    fetchStoredPublicKey(accountId),\n    ton.pickAccountWallet(accountId),\n  ]);\n\n  return [{\n    address,\n    publicKey,\n    walletVersion: wallet ? ton.resolveWalletVersion(wallet) : undefined,\n  }];\n}\n\nexport async function sendTransaction(params: {\n  to: string;\n  value: string;\n  data?: string;\n  dataType?: 'text' | 'hex' | 'base64' | 'boc';\n  stateInit?: string;\n}) {\n  const accountId = await getCurrentAccountIdOrFail();\n\n  const {\n    value: amount, to: toAddress, data, dataType, stateInit,\n  } = params;\n\n  let processedData;\n  if (data) {\n    switch (dataType) {\n      case 'hex':\n        processedData = hexToBytes(data);\n        break;\n      case 'base64':\n        processedData = base64ToBytes(data);\n        break;\n      case 'boc':\n        processedData = ton.oneCellFromBoc(base64ToBytes(data));\n        break;\n      default:\n        processedData = data;\n    }\n  }\n\n  const processedStateInit = stateInit ? ton.oneCellFromBoc(base64ToBytes(stateInit)) : undefined;\n\n  await openPopupWindow();\n  await waitLogin();\n\n  const checkResult = await ton.checkTransactionDraft(\n    accountId, TON_TOKEN_SLUG, toAddress, amount, processedData, processedStateInit,\n  );\n\n  if (!checkResult || checkResult?.error) {\n    onPopupUpdate({\n      type: 'showError',\n      error: checkResult?.error,\n    });\n\n    return false;\n  }\n\n  const { promiseId, promise } = createDappPromise();\n\n  const account = await fetchStoredAccount(accountId);\n  if (account?.ledger) {\n    return sendLedgerTransaction(accountId, promiseId, promise, checkResult.fee!, params);\n  }\n\n  onPopupUpdate({\n    type: 'createTransaction',\n    promiseId,\n    toAddress,\n    amount,\n    fee: checkResult.fee!,\n    ...(dataType === 'text' && {\n      comment: data,\n    }),\n  });\n\n  const password = await promise;\n\n  const result = await ton.submitTransfer(\n    accountId, password, TON_TOKEN_SLUG, toAddress, amount, processedData, processedStateInit,\n  );\n\n  if ('error' in result) {\n    return false;\n  }\n\n  const fromAddress = await fetchStoredAddress(accountId);\n  createLocalTransaction(onPopupUpdate, accountId, {\n    amount,\n    fromAddress,\n    toAddress,\n    fee: checkResult.fee!,\n    slug: TON_TOKEN_SLUG,\n    ...(dataType === 'text' && {\n      comment: data,\n    }),\n  });\n\n  return true;\n}\n\nasync function sendLedgerTransaction(\n  accountId: string,\n  promiseId: string,\n  promise: Promise<any>,\n  fee: string,\n  params: {\n    to: string;\n    value: string;\n    data?: string;\n    dataType?: 'text' | 'hex' | 'base64' | 'boc';\n    stateInit?: string;\n  },\n) {\n  const { network } = parseAccountId(accountId);\n  const fromAddress = await fetchStoredAddress(accountId);\n  const {\n    to: toAddress, value: amount, data, dataType, stateInit,\n  } = params;\n\n  let payloadBoc: string | undefined;\n\n  if (data) {\n    switch (dataType) {\n      case 'hex':\n        payloadBoc = await ton.packPayloadToBoc(hexToBytes(data));\n        break;\n      case 'base64':\n        payloadBoc = await ton.packPayloadToBoc(base64ToBytes(data));\n        break;\n      case 'boc':\n        payloadBoc = data;\n        break;\n      case 'text':\n        payloadBoc = await ton.packPayloadToBoc(data);\n        break;\n      default:\n        payloadBoc = undefined;\n    }\n  }\n\n  const parsedPayload = payloadBoc ? await ton.parsePayloadBase64(network, toAddress, payloadBoc) : undefined;\n\n  onPopupUpdate({\n    type: 'createTransaction',\n    promiseId,\n    toAddress,\n    amount,\n    fee,\n    ...(dataType === 'text' && {\n      comment: data,\n    }),\n    stateInit,\n    rawPayload: payloadBoc,\n    parsedPayload,\n  });\n\n  try {\n    const [signedMessage] = await promise as ApiSignedTransfer[];\n\n    await ton.sendSignedMessage(accountId, signedMessage);\n  } catch (err) {\n    logDebugError('sendLedgerTransaction', err);\n    return false;\n  }\n\n  createLocalTransaction(onPopupUpdate, accountId, {\n    amount,\n    fromAddress,\n    toAddress,\n    fee,\n    slug: TON_TOKEN_SLUG,\n    ...(dataType === 'text' && {\n      comment: data,\n    }),\n  });\n\n  return true;\n}\n\nexport async function rawSign({ data }: { data: string }) {\n  const accountId = await getCurrentAccountIdOrFail();\n\n  await openPopupWindow();\n  await waitLogin();\n\n  const { promiseId, promise } = createDappPromise();\n\n  onPopupUpdate({\n    type: 'createSignature',\n    promiseId,\n    dataHex: data,\n  });\n\n  const password = await promise;\n\n  return ton.rawSign(accountId, password, data);\n}\n","import type { ApiInitArgs, ApiUpdate, OnApiUpdate } from '../types';\n\nimport { IS_SSE_SUPPORTED } from '../../config';\nimport { connectUpdater, startStorageMigration } from '../common/helpers';\nimport * as dappMethods from '../dappMethods';\nimport * as legacyDappMethods from '../dappMethods/legacy';\nimport { IS_DAPP_SUPPORTED, IS_EXTENSION } from '../environment';\nimport * as tonConnect from '../tonConnect';\nimport { resetupSseConnection, sendSseDisconnect } from '../tonConnect/sse';\nimport * as methods from '.';\n\nexport default async function init(_onUpdate: OnApiUpdate, args: ApiInitArgs) {\n  const onUpdate: OnApiUpdate = (update: ApiUpdate) => _onUpdate(update);\n\n  connectUpdater(onUpdate);\n\n  methods.initPolling(onUpdate, methods.isAccountActive, args);\n  methods.initTransactions(onUpdate);\n  void methods.initWallet(onUpdate);\n  methods.initStaking(onUpdate);\n\n  if (IS_DAPP_SUPPORTED) {\n    const onDappChanged = IS_SSE_SUPPORTED ? resetupSseConnection : undefined;\n    const onDappDisconnected = IS_SSE_SUPPORTED ? sendSseDisconnect : undefined;\n    methods.initDapps(onUpdate, onDappChanged, onDappDisconnected);\n    tonConnect.initTonConnect(onUpdate);\n  }\n  if (IS_EXTENSION) {\n    void methods.initExtension(onUpdate);\n    legacyDappMethods.initLegacyDappMethods(onUpdate);\n    dappMethods.initDappMethods(onUpdate);\n  }\n\n  await startStorageMigration();\n\n  if (IS_SSE_SUPPORTED) {\n    void resetupSseConnection();\n  }\n}\n","import type { MethodArgs, Methods } from '../../methods/types';\nimport type { ApiInitArgs, OnApiUpdate } from '../../types';\n\nimport { POPUP_PORT } from './config';\nimport { createExtensionInterface } from '../../../util/createPostMessageInterface';\nimport { disconnectUpdater } from '../../common/helpers';\nimport * as methods from '../../methods';\nimport init from '../../methods/init';\n\ncreateExtensionInterface(POPUP_PORT, (name: string, origin?: string, ...args: any[]) => {\n  if (name === 'init') {\n    return init(args[0] as OnApiUpdate, args[1] as ApiInitArgs);\n  } else {\n    const method = methods[name as keyof Methods];\n    // @ts-ignore\n    return method(...args as MethodArgs<keyof Methods>);\n  }\n}, undefined, disconnectUpdater);\n","export const POPUP_PORT = 'MyTonWallet_popup';\nexport const CONTENT_SCRIPT_PORT = 'MyTonWallet_contentScript';\nexport const PAGE_CONNECTOR_CHANNEL = 'MyTonWallet_pageConnector';\n","import type { TonConnectMethodArgs, TonConnectMethods } from '../../tonConnect/types/misc';\nimport type { OnApiDappUpdate } from '../../types/dappUpdates';\nimport type {\n  DappMethodArgs,\n  DappMethods,\n  LegacyDappMethodArgs,\n  LegacyDappMethods,\n} from '../../dappMethods/types';\n\nimport { CONTENT_SCRIPT_PORT, PAGE_CONNECTOR_CHANNEL } from './config';\nimport { createExtensionInterface } from '../../../util/createPostMessageInterface';\nimport * as dappApi from '../../dappMethods';\nimport * as legacyDappApi from '../../dappMethods/legacy';\nimport * as tonConnectApi from '../../tonConnect';\n\nconst ALLOWED_METHODS = new Set([\n  'ton_getBalance',\n  'ton_requestAccounts',\n  'ton_requestWallets',\n  'ton_sendTransaction',\n  'ton_rawSign',\n  'flushMemoryCache',\n  'prepareTransaction',\n  'tonConnect_connect',\n  'tonConnect_reconnect',\n  'tonConnect_disconnect',\n  'tonConnect_sendTransaction',\n  'tonConnect_deactivate',\n]);\n\ncreateExtensionInterface(CONTENT_SCRIPT_PORT, (\n  name: string, origin?: string, ...args: any[]\n) => {\n  if (name === 'init') {\n    return dappApi.connectDapp(args[0] as OnApiDappUpdate, legacyDappApi.onDappSendUpdates);\n  }\n\n  if (!ALLOWED_METHODS.has(name)) {\n    throw new Error('Method not allowed');\n  }\n\n  if (name.startsWith('ton_')) {\n    name = name.replace('ton_', '');\n    const method = legacyDappApi[name as keyof LegacyDappMethods];\n    // @ts-ignore\n    return method(...args as keyof LegacyDappMethodArgs<keyof LegacyDappMethods>);\n  }\n\n  if (name.startsWith('tonConnect_')) {\n    const request = { origin };\n    name = name.replace('tonConnect_', '');\n    const method = tonConnectApi[name as keyof TonConnectMethods];\n    // @ts-ignore\n    return method(...[request].concat(args) as TonConnectMethodArgs<keyof TonConnectMethods>);\n  }\n\n  const method = dappApi[name as keyof DappMethods];\n  // @ts-ignore\n  return method(...args as DappMethodArgs<keyof DappMethods>);\n}, PAGE_CONNECTOR_CHANNEL, (onUpdate: OnApiDappUpdate) => {\n  dappApi.deactivateDapp(onUpdate);\n}, true);\n","type CollectionByKey<Member> = Record<number | string, Member>;\n\ntype OrderDirection =\n  'asc'\n  | 'desc';\n\ninterface OrderCallback<T> {\n  (member: T): any;\n}\n\nexport function buildCollectionByKey<T extends AnyLiteral>(collection: T[], key: keyof T) {\n  return collection.reduce((byKey: CollectionByKey<T>, member: T) => {\n    byKey[member[key]] = member;\n\n    return byKey;\n  }, {});\n}\n\nexport function mapValues<R extends any, M extends any>(\n  byKey: CollectionByKey<M>,\n  callback: (member: M, key: string, index: number, originalByKey: CollectionByKey<M>) => R,\n): CollectionByKey<R> {\n  return Object.keys(byKey).reduce((newByKey: CollectionByKey<R>, key, index) => {\n    newByKey[key] = callback(byKey[key], key, index, byKey);\n    return newByKey;\n  }, {});\n}\n\nexport function pick<T, K extends keyof T>(object: T, keys: K[]) {\n  return keys.reduce((result, key) => {\n    result[key] = object[key];\n    return result;\n  }, {} as Pick<T, K>);\n}\n\nexport function pickTruthy<T, K extends keyof T>(object: T, keys: K[]) {\n  return keys.reduce((result, key) => {\n    if (object[key]) {\n      result[key] = object[key];\n    }\n\n    return result;\n  }, {} as Pick<T, K>);\n}\n\nexport function omit<T extends object, K extends keyof T>(object: T, keys: K[]): Omit<T, K> {\n  const stringKeys = new Set(keys.map(String));\n  const savedKeys = Object.keys(object)\n    .filter((key) => !stringKeys.has(key)) as Array<Exclude<keyof T, K>>;\n\n  return pick(object, savedKeys);\n}\n\nexport function orderBy<T>(\n  collection: T[],\n  orderRule: (keyof T) | OrderCallback<T> | ((keyof T) | OrderCallback<T>)[],\n  mode: OrderDirection | [OrderDirection, OrderDirection] = 'asc',\n): T[] {\n  function compareValues(a: T, b: T, currentOrderRule: (keyof T) | OrderCallback<T>, isAsc: boolean) {\n    const aValue = (typeof currentOrderRule === 'function' ? currentOrderRule(a) : a[currentOrderRule]) || 0;\n    const bValue = (typeof currentOrderRule === 'function' ? currentOrderRule(b) : b[currentOrderRule]) || 0;\n\n    return isAsc ? aValue - bValue : bValue - aValue;\n  }\n\n  if (Array.isArray(orderRule)) {\n    const [mode1, mode2] = Array.isArray(mode) ? mode : [mode, mode];\n    const [orderRule1, orderRule2] = orderRule;\n    const isAsc1 = mode1 === 'asc';\n    const isAsc2 = mode2 === 'asc';\n\n    return collection.sort((a, b) => {\n      return compareValues(a, b, orderRule1, isAsc1) || compareValues(a, b, orderRule2, isAsc2);\n    });\n  }\n\n  const isAsc = mode === 'asc';\n  return collection.sort((a, b) => {\n    return compareValues(a, b, orderRule, isAsc);\n  });\n}\n\nexport function unique<T extends any>(array: T[]): T[] {\n  return Array.from(new Set(array));\n}\n\nexport function compact<T extends any>(array: T[]) {\n  return array.filter(Boolean);\n}\n\nexport function areSortedArraysEqual(array1: any[], array2: any[]) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  return array1.every((item, i) => item === array2[i]);\n}\n\nexport function split<T extends any>(array: T[], chunkSize: number) {\n  const result: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n\nexport function cloneDeep<T>(value: T): T {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep) as typeof value;\n  }\n\n  return Object.keys(value).reduce((acc, key) => {\n    acc[key as keyof T] = cloneDeep(value[key as keyof T]);\n    return acc;\n  }, {} as T);\n}\n\nfunction isObject(value: any): value is object {\n  // eslint-disable-next-line no-null/no-null\n  return typeof value === 'object' && value !== null;\n}\n\nexport function findLast<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): T | undefined {\n  let cursor = array.length;\n\n  while (cursor--) {\n    if (predicate(array[cursor], cursor, array)) {\n      return array[cursor];\n    }\n  }\n\n  return undefined;\n}\n\nexport function range(start: number, end: number) {\n  const arr: number[] = [];\n  for (let i = start; i < end;) {\n    arr.push(i++);\n  }\n  return arr;\n}\n\nexport function fromKeyValueArrays<T>(keys: string[], values: T[] | T) {\n  return keys.reduce((acc, key, index) => {\n    acc[key] = Array.isArray(values) ? values[index] : values;\n    return acc;\n  }, {} as Record<string, T>);\n}\n\nexport function extractKey<T, K extends keyof T>(array: T[], key: K): T[K][] {\n  return array.map((value) => value[key]);\n}\n","import { DEBUG } from '../config';\n\nexport function logDebugError(message: string, ...args: any[]) {\n  if (DEBUG) {\n    // eslint-disable-next-line no-console\n    console.error(`[DEBUG][${message}]`, ...args);\n  }\n}\n\nexport function logDebug(message: any, ...args: any[]) {\n  if (DEBUG) {\n    // eslint-disable-next-line no-console\n    console.log('[DEBUG]', message, ...args);\n  }\n}\n","export type Scheduler = typeof requestAnimationFrame | typeof onTickEnd;\n\nexport function debounce<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true,\n) {\n  let waitingTimeout: number | undefined;\n\n  return (...args: Parameters<F>) => {\n    if (waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = undefined;\n    } else if (shouldRunFirst) {\n      fn(...args);\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    waitingTimeout = self.setTimeout(() => {\n      if (shouldRunLast) {\n        fn(...args);\n      }\n\n      waitingTimeout = undefined;\n    }, ms);\n  };\n}\n\nexport function throttle<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n) {\n  let interval: number | undefined;\n  let isPending: boolean;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    isPending = true;\n    args = _args;\n\n    if (!interval) {\n      if (shouldRunFirst) {\n        isPending = false;\n        fn(...args);\n      }\n\n      // eslint-disable-next-line no-restricted-globals\n      interval = self.setInterval(() => {\n        if (!isPending) {\n          // eslint-disable-next-line no-restricted-globals\n          self.clearInterval(interval!);\n          interval = undefined;\n          return;\n        }\n\n        isPending = false;\n        fn(...args);\n      }, ms);\n    }\n  };\n}\n\nexport function throttleWithTickEnd<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(onTickEnd, fn);\n}\n\nexport function throttleWith<F extends AnyToVoidFunction>(schedulerFn: Scheduler, fn: F) {\n  let waiting = false;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    args = _args;\n\n    if (!waiting) {\n      waiting = true;\n\n      schedulerFn(() => {\n        waiting = false;\n        fn(...args);\n      });\n    }\n  };\n}\n\nexport function onIdle(cb: NoneToVoidFunction, timeout?: number) {\n  // eslint-disable-next-line no-restricted-globals\n  if (self.requestIdleCallback) {\n    // eslint-disable-next-line no-restricted-globals\n    self.requestIdleCallback(cb, { timeout });\n  } else {\n    onTickEnd(cb);\n  }\n}\n\nexport const pause = (ms: number) => new Promise<void>((resolve) => {\n  setTimeout(() => resolve(), ms);\n});\n\nexport function rafPromise() {\n  return new Promise<void>((resolve) => {\n    fastRaf(resolve);\n  });\n}\n\nconst FAST_RAF_TIMEOUT_FALLBACK_MS = 300;\n\nlet fastRafCallbacks: Set<NoneToVoidFunction> | undefined;\nlet fastRafFallbackCallbacks: Set<NoneToVoidFunction> | undefined;\nlet fastRafFallbackTimeout: number | undefined;\n\n// May result in an immediate execution if called from another RAF callback which was scheduled\n// (and therefore is executed) earlier than RAF callback scheduled by `fastRaf`\nexport function fastRaf(callback: NoneToVoidFunction, withTimeoutFallback = false) {\n  if (!fastRafCallbacks) {\n    fastRafCallbacks = new Set([callback]);\n\n    requestAnimationFrame(() => {\n      const currentCallbacks = fastRafCallbacks!;\n\n      fastRafCallbacks = undefined;\n      fastRafFallbackCallbacks = undefined;\n\n      if (fastRafFallbackTimeout) {\n        clearTimeout(fastRafFallbackTimeout);\n        fastRafFallbackTimeout = undefined;\n      }\n\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    fastRafCallbacks.add(callback);\n  }\n\n  if (withTimeoutFallback) {\n    if (!fastRafFallbackCallbacks) {\n      fastRafFallbackCallbacks = new Set([callback]);\n    } else {\n      fastRafFallbackCallbacks.add(callback);\n    }\n\n    if (!fastRafFallbackTimeout) {\n      fastRafFallbackTimeout = window.setTimeout(() => {\n        const currentTimeoutCallbacks = fastRafFallbackCallbacks!;\n\n        if (fastRafCallbacks) {\n          currentTimeoutCallbacks.forEach(fastRafCallbacks.delete, fastRafCallbacks);\n        }\n        fastRafFallbackCallbacks = undefined;\n\n        if (fastRafFallbackTimeout) {\n          clearTimeout(fastRafFallbackTimeout);\n          fastRafFallbackTimeout = undefined;\n        }\n\n        currentTimeoutCallbacks.forEach((cb) => cb());\n      }, FAST_RAF_TIMEOUT_FALLBACK_MS);\n    }\n  }\n}\n\nlet onTickEndCallbacks: NoneToVoidFunction[] | undefined;\n\nexport function onTickEnd(callback: NoneToVoidFunction) {\n  if (!onTickEndCallbacks) {\n    onTickEndCallbacks = [callback];\n\n    Promise.resolve().then(() => {\n      const currentCallbacks = onTickEndCallbacks!;\n      onTickEndCallbacks = undefined;\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    onTickEndCallbacks.push(callback);\n  }\n}\n\nlet beforeUnloadCallbacks: NoneToVoidFunction[] | undefined;\n\nexport function onBeforeUnload(callback: NoneToVoidFunction, isLast = false) {\n  if (!beforeUnloadCallbacks) {\n    beforeUnloadCallbacks = [];\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('beforeunload', () => {\n      beforeUnloadCallbacks!.forEach((cb) => cb());\n    });\n  }\n\n  if (isLast) {\n    beforeUnloadCallbacks.push(callback);\n  } else {\n    beforeUnloadCallbacks.unshift(callback);\n  }\n\n  return () => {\n    beforeUnloadCallbacks = beforeUnloadCallbacks!.filter((cb) => cb !== callback);\n  };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t204: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkmytonwallet\"] = self[\"webpackChunkmytonwallet\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [780,391,466,412,220], () => (__webpack_require__(30514)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","IS_EXTENSION","Boolean","_self","self","chrome","runtime","id","IS_CHROME_EXTENSION","_self2","system","IS_FIREFOX_EXTENSION","IS_DAPP_SUPPORTED","process","APP_VERSION","DEBUG","IS_SSE_SUPPORTED","MAIN_ACCOUNT_ID","TONHTTPAPI_MAINNET_URL","TONHTTPAPI_MAINNET_API_KEY","TONHTTPAPI_TESTNET_URL","TONHTTPAPI_TESTNET_API_KEY","BRILLIANT_API_BASE_URL","TON_TOKEN_SLUG","PROXY_HOSTS","STAKING_POOLS","callbackState","Map","createExtensionInterface","portName","api","channel","cleanUpdater","withAutoInit","arguments","length","undefined","extension","onConnect","addListener","port","_port$sender","name","url","sender","includes","origin","URL","dAppUpdater","update","sendToOrigin","type","data","postMessage","onerror","e","_e$error","console","error","message","addEventListener","_e$reason","reason","handleErrors","onMessage","onDisconnect","args","async","onUpdate","_api$init","promise","init","call","messageId","withCallback","callback","_len","callbackArgs","Array","_key","lastArg","obj","ArrayBuffer","ImageBitmap","set","push","response","arrayBuffer","err","logDebugError","delete","get","isCanceled","parseAccountId","accountId","blockchain","network","split","Number","buildAccountId","account","storage","extensionStorage","idb","StorageType","IndexedDb","LocalStorage","localStorage","ExtensionLocal","bytesToHex","bytes","TonWeb","hexToBytes","hex","bytesToBase64","base64ToBytes","sha256","handleFetchErrors","ok","Error","statusText","isKnownStakingPool","address","some","poolPart","endsWith","callBackendPost","path","fetch","method","headers","body","JSON","stringify","json","callBackendGet","Object","entries","forEach","_ref","key","value","searchParams","toString","knownAddresses","scamMarkers","tryUpdateKnownAddresses","mapValues","map","x","RegExp","getKnownAddresses","getScamMarkers","txCallbacks","createCallbackManager","localCounter","getNextLocalId","Date","now","actualStateVersion","migrationEnsurePromise","currentOnUpdate","resolveBlockchainKey","toInternalAccountId","buildInternalAccountId","createLocalTransaction","params","amount","fromAddress","toAddress","comment","fee","slug","encryptedComment","localTransaction","restParams","updateTransactionMetadata","txId","timestamp","isIncoming","buildLocalTransaction","transaction","Promise","resolve","addCallback","removeCallback","result","whenTxComplete","then","localTxId","metadata","sm","test","find","isScam","isUpdaterAlive","MIN_ACCOUNT_NUMBER","loginResolve","loginPromise","getAccountIds","keys","getItem","getNewAccountId","ids","Math","max","fetchStoredAccount","getAccountValue","fetchStoredPublicKey","fetchStoredAddress","_await$storage$getIte","internalId","removeAccountValue","removedValue","restData","setItem","setAccountValue","getCurrentAccountId","waitLogin","generateMnemonic","tonWebMnemonic","validateMnemonic","mnemonic","mnemonicToSeed","secretKey","slice","seedToKeyPair","seed","nacl","keyPair","fromSeed","encryptMnemonic","password","plaintext","join","pwUtf8","TextEncoder","encode","pwHash","crypto","subtle","digest","iv","getRandomValues","Uint8Array","alg","importKey","ptUint8","ctBuffer","encrypt","ctStr","from","byte","String","fromCharCode","ctBase64","btoa","b","fetchMnemonic","mnemonicEncrypted","encrypted","match","parseInt","atob","ctUint8","ch","charCodeAt","plainBuffer","decrypt","TextDecoder","decode","decryptMnemonic","fetchPrivateKey","seedBase64","privateKey","fetchKeyPair","rawSign","dataHex","detached","verifyPassword","MAX_LIMIT","configurationMainnet","Configuration","basePath","configurationTestnet","tonapiioByNetwork","mainnet","configuration","blockchainApi","BlockchainApi","nftApi","NFTApi","accountsApi","AccountsApi","testnet","fetchNftItems","addresses","tonapiioErrorHandler","getNftItemsByAddresses","getAccountsRequest","accountIds","nftItems","fn","defaultValue","ResponseError","catch","TOKEN_TRANSFER_TON_AMOUNT","TOKEN_TRANSFER_TON_FORWARD_AMOUNT","STAKE_COMMENT","UNSTAKE_COMMENT","ATTEMPTS","DEFAULT_DECIMALS","LEDGER_SUPPORTED_PAYLOADS","OpCode","JettonOpCode","NftOpCode","stringifyTxId","lt","hash","parseTxId","buildTokenSlug","minterAddress","replace","toLowerCase","Cell","Address","JettonMinter","JettonWallet","jetton","tonwebByNetwork","CustomHttpProvider","apiKey","resolveTokenWalletAddress","withCacheAsync","minter","getTonWeb","provider","toBase64Address","getJettonWalletAddress","resolveTokenMinterAddress","tokenWalletAddress","tokenWallet","getData","jettonMinterAddress","getWalletPublicKey","publicKeyHex","call2","fetchTransactions","limit","fromTxId","toTxId","tonWeb","fromLt","fromHash","toLt","getTransactions","parseRawTransaction","flat","rawTx","utime","transaction_id","in_msg","source","msgs","out_msgs","msg","i","destination","getComment","getEncryptedComment","extraData","getRawBody","msg_data","base64","text","oneCellFromBoc","boc","oneFromBoc","isBounceable","toRawAddress","bnToAddress","DEFAULT_WALLET_VERSION","isWalletInitialized","walletOrAddress","getWalletInfo","isInitialized","isActiveSmartContract","isWallet","publicKeyToAddress","publicKey","wallet","buildWallet","getAddress","walletVersion","WalletClass","all","wc","account_state","accountState","seqno","balance","getAccountBalance","getWalletBalance","getWalletSeqno","pickBestWallet","walletClasses","values","allWallets","BigInt","withBiggestBalance","compact","reduce","best","current","getWalletStateInit","pickAccountWallet","stateInit","createStateInit","toBoc","version","_allWallets$find","list","walletAddress","w","pickWalletByAddress","resolveWalletVersion","getAccountNfts","offset","rawNfts","getNftItemsByOwner","indirectOwnership","fetchAccountNfts","buildNft","rawNft","index","collection","image","previews","sale","thumbnail","resolution","isOnSale","collectionAddress","collectionName","getNftUpdates","fromSec","_events$0$timestamp","_events$","events","getEventsByAccount","startDate","fetchAccountEvents","reverse","updates","event","action","actions","to","nftAddress","isPurchase","nftPurchase","nftItemTransfer","recipient","nft","rawNftAddress","buyer","WORKCHAIN","Workchain","BaseChain","ed25519","require","aesjs","getAesCbcState","ModeOfOperation","cbc","combineSecrets","a","hmacAlgo","hmacKey","signature","sign","hmacSha512","encryptMessageComment","myPublicKey","theirPublicKey","myPrivateKey","senderAddress","commentBytes","salt","encryptedBytes","sharedSecret","getSharedSecret","prefix","dataLength","minPadding","prefixLength","getRandomPrefix","combined","msgKey","res","cbcStateSecret","encryptDataWithPrefix","encryptDataImpl","prefixedEncrypted","encryptData","payload","buffer","Buffer","alloc","writeUInt32BE","Encrypted","decryptMessageComment","encryptedData","decryptedBytes","decryptedData","gotMsgKey","doDecrypt","decryptDataImpl","decryptData","IPFS_GATEWAY_BASE_URL","ONCHAIN_CONTENT_PREFIX","toBounceableAddress","urlSafe","bounceable","fixIpfsUrl","dictSnakeBufferValue","parse","sliceToVal","s","v","isFirst","loadUint","concat","loadBuffer","remainingBits","remainingRefs","loadRef","beginParse","serialize","jettonOnChainMetadataSpec","uri","description","symbol","decimals","fetchJettonMetadata","fetchJsonMetadata","pick","parsePayloadBase64","_await$parsePayloadSl","dataToSlice","parsePayloadSlice","opCode","Comment","loadStringTail","queryId","Transfer","_forwardPayload","loadCoins","loadAddress","responseDestination","loadMaybeAddress","customPayload","loadMaybeRef","forwardAmount","forwardPayload","builder","Builder","storeBits","loadBits","range","storeRef","endCell","TransferOwnership","_forwardPayload2","_nft$metadata","newOwner","nftName","fromBoc","Slice","BitReader","BitString","axios","adapter","clientByNetwork","TonClient","endpoint","walletClassMap","simpleR1","WalletContractV1R1","simpleR2","WalletContractV1R2","simpleR3","WalletContractV1R3","v2R1","WalletContractV2R1","v2R2","WalletContractV2R2","v3R1","WalletContractV3R1","v3R2","WalletContractV3R2","v4R1","v4R2","WalletContractV4","getTonWalletContract","walletClass","create","workchain","getTonClient","zonesRegex","ton","vip","zones","isDnsDomain","zone","isVipDnsDomain","removeZone","DnsCollection","VIP_DNS_COLLECTION","resolveAddress","dns","domain","tonweb","_await$tonweb$dns$get","_await$DnsCollection$","base","getWalletAddress","knownTokens","getAccountTokenBalances","balancesRaw","getJettonsBalances","balances","fetchJettonBalances","parseTokenBalance","filter","balanceRaw","token","buildTokenByMetadata","buildTokenTransfer","resolveTokenBySlug","tokenAddress","getTokenWallet","tokenAmount","responseAddress","cell","bits","writeUint","writeCoins","BN","writeAddress","writeBit","getFreeBits","writeBytes","refs","buildTokenTransferBody","getKnownTokens","addKnownTokens","tokens","quote","price","percentChange1h","percentChange24h","percentChange7d","percentChange30d","importToken","jettonContentUri","jettonContentCell","contract","getJettonData","totalSupply","adminAddress","getJettonMinterData","array","contentSlice","dict","loadDict","Dictionary","Keys","_dict$get","sha256Key","val","parseJettonOnchainMetadata","getJettonMetadata","image_data","imageData","base64toString","fromNano","DEFAULT_FEE","DEFAULT_EXPIRE_AT_TIMEOUT_SEC","GET_TRANSACTIONS_LIMIT","GET_TRANSACTIONS_MAX_LIMIT","WAIT_SEQNO_TIMEOUT","WAIT_SEQNO_PAUSE","lastTransfers","checkTransactionDraft","tokenSlug","shouldEncrypt","resolvedAddress","ApiTransactionDraftError","DomainNotResolved","isValid","InvalidToAddress","addressInfo","addressName","InvalidAmount","Unexpected","WalletNotInitialized","ledger","isValidLedgerComment","UnsupportedHardwarePayload","tokenBalance","getTokenWalletBalance","InsufficientBalance","calculateFee","signTransaction","query","submitTransfer","toPublicKey","waitLastTransfer","toWalletInfo","ApiTransactionError","send","updateLastTransfer","resolveTransactionError","IncorrectDeviceTime","UnsuccesfulTransfer","methods","transfer","sendMode","getAccountNewestTxId","fetchNewestTxId","getAccountTransactionSlice","transactions","_transaction$extraDat","parsedPayload","parseWalletTransactionBody","updateTransactionType","omitExtraData","getMergedTransactionSlice","lastTxIds","toncoin","lastTonTxId","tokenLastTxIds","tonTxs","lastTonTxLt","results","lastTxId","getTokenTransactionSlice","allTxs","sort","compareTransactions","tx","parsedData","fromBase64","InternalTransfer","jettonAmount","forwardComment","loadBit","operation","parseJettonWalletMsgBody","parseTokenTransaction","omit","amountNumber","abs","checkMultiTransactionDraft","messages","totalAmount","signMultiTransaction","submitMultiTransfer","expireAt","preparedMessages","round","transfers","lastTransfer","waitUntil","currentSeqno","pause","waitIncrementSeqno","fees","estimateFee","source_fees","in_fwd_fee","storage_fee","gas_fee","fwd_fee","sendSignedMessage","open","TonCell","sendSignedMessages","attempts","attempt","successNumber","decryptComment","NominatorPool","constructor","options","super","this","getListNominators","bind","getPoolData","getMaxPunishment","myAddress","item","pendingDepositAmount","withdrawRequested","toNumber","state","nominatorsCount","stakeAmountSent","validatorAmount","validatorAddress","validatorRewardShare","maxNominatorsCount","minValidatorStake","minNominatorStake","nominators","withdrawRequests","stakeAt","validatorSetChangesCount","validatorSetChangeTime","stakeHeldFor","configProposalVotings","stake","toNano","UNSTAKE_AMOUNT","MIN_STAKE_AMOUNT","DISABLE_CACHE_PERIOD","fetchStakingStateMemo","memoized","stakingState","poolAddress","checkStakeDraft","getStakingState","checkUnstakeDraft","submitStake","onStakingChangeExpected","submitUnstake","disableCache","getPoolContract","isUnstakeRequested","currentNominator","n","parseFloat","getBackendStakingState","packPayloadToBoc","payloadCell","writeString","ApiBaseError","displayError","captureStackTrace","ApiUserRejectsError","deferreds","Deferred","_defineProperty","reject","createDappPromise","promiseId","generateUniqueId","resolveDappPromise","rejectDappPromise","currentWindowId","readyPromise","WINDOW_DEFAULTS","top","left","width","height","openPopupWindow","windows","focused","lastWindowId","wasWindowFound","removeItem","createWindow","isRetryingWithoutLastState","lastState","window","onPopupUpdate","display","getInfo","firstScreen","bounds","onClicked","onRemoved","removedWindowId","setInterval","currentWindow","getCurrent","INIT_UPDATE_DELAY","dappUpdaters","initDappMethods","_onPopupUpdate","connectDapp","onDappUpdate","onDappSendUpdates","isTonMagicEnabled","isDeeplinkHookEnabled","sendUpdates","isEnabled","setTimeout","deactivateDapp","findIndex","updater","splice","updateDapps","prepareTransaction","getCurrentAccountIdOrFail","flushMemoryCache","webRequest","handlerBehaviorChanged","clearCache","activeDappByAccountId","onDappsChanged","onDappDisconnected","initDapps","_onUpdate","_onDappsChanged","_onDappDisconnected","getActiveDapp","findActiveDappAccount","deactivateAccountDapp","acc","deactivateAllDapps","updateDapp","dapp","getDapp","addDapp","dapps","getDappsByOrigin","deleteDapp","dontNotifyDapp","isDappActive","deleteAllDapps","origins","getDapps","isDappConnected","getDappsState","removeAccountDapps","removeAllDapps","proxies","hostWithPort","host","proxy","arr","floor","random","PROXY_PAC_SCRIPT","isProxyEnabled","initExtension","doProxy","doDeeplinkHook","setupDefaultExtensionFeatures","clearExtensionFeatures","doMagic","onRequest","firefoxOnRequest","urls","removeListener","settings","scope","mode","pacScript","clear","initStaking","blockchains","poolState","startOfCycle","endOfCycle","POLLING_INTERVAL","BACKEND_POLLING_INTERVAL","LONG_BACKEND_POLLING_INTERVAL","TRANSACTIONS_WAITING_PAUSE","FIRST_TRANSACTIONS_LIMIT","NFT_FULL_UPDATE_FREQUNCY","isAccountActive","preloadEnsurePromise","pricesBySlug","lastBalanceCache","initPolling","_isAccountActive","tryUpdateTokens","setupBackendPolling","setupLongBackendPolling","registerNewTokens","tokenBalances","areNewTokensFound","sendUpdateTokens","setupBalanceBasedPolling","newestTxIds","nftUpdates","isFirstRun","nftFromSec","localOnUpdate","logAndRescue","nfts","cache","changedTokenSlugs","fromEntries","newTxIds","processNewTokenTransactions","tokenSlugs","allTransactions","newestTxId","runCallbacks","pricesData","_ref2","slugs","setupBackendStakingStatePolling","backendStakingState","waitDataPreload","activeAccountId","activateAccount","prevAccountId","isFirstLogin","activeDappOrigin","onActiveDappAccountUpdated","deactivateAllAccounts","deactivateCurrentAccount","fetchAccount","getActiveAccountId","createWallet","storeAccount","importMnemonic","importLedgerWallet","walletInfo","driver","deviceId","deviceName","accountInfo","storeHardwareAccount","resetAccounts","removeAccount","nextAccountId","initWallet","isTonProxyEnabled","getMnemonic","nonHardwareAccounts","info","hasLedger","accountById","buildCollectionByKey","min","getMainAccountId","confirmDappRequest","dappPromises","confirmDappRequestConnect","cancelDappRequest","fetchAddress","fetchPublicKey","initTransactions","fetchTokenTransactionSlice","fetchAllTransactionSlice","sendSignedTransferMessage","sendSignedTransferMessages","fetchNfts","blockchainKey","CONNECT_EVENT_ERROR_CODES","SEND_TRANSACTION_ERROR_CODES","SIGN_DATA_ERROR_CODES","TonConnectError","code","ManifestContentError","MANIFEST_CONTENT_ERROR","UnknownError","BadRequestError","isValidString","maxLength","isValidUrl","resolveInit","initPromise","initTonConnect","connect","request","validateRequest","fetchDappMetadata","manifestUrl","connectedAt","addressItem","items","proofItem","proof","errors","openExtensionPopup","getCurrentAccountOrFail","promiseResult","permissions","additionalAccountIds","dappsByAccount","addDappToAccounts","reconnect","proofReplyItem","timestampBuffer","allocUnsafe","writeBigInt64LE","domainBuffer","domainLengthBuffer","writeInt32LE","byteLength","addressWorkchainBuffer","writeInt32BE","addressBuffer","hashPart","messageBuffer","bufferToSign","buildTonProofReplyItem","signTonProof","formatConnectError","oldAccountId","activateDapp","buildTonAddressReplyItem","disconnect","sendTransaction","txPayload","validUntil","valid_until","isLedger","checkResult","_ref5","handleDraftError","checkTransactionMessages","transactionsForRequest","rawPayload","_ref4","prepareTransactionForRequest","submitResult","PartialTransactionFailure","_ref3","UNKNOWN_ERROR","errorMessage","apiErrors","USER_REJECTS_ERROR","signData","METHOD_NOT_SUPPORTED","deactivate","CHAIN","MAINNET","TESTNET","walletStateInit","lengthBytes","iconUrl","skipConnection","lastAccountId","lastConnectedAccountId","byOrigin","findLastConnectedAccount","force","BRIDGE_URL","TTL_SEC","NONCE_SIZE","sseEventSource","sseDapps","startSseConnection","deviceInfo","appClientId","ret","logDebug","tonConnect","device","secretKeyArray","publicKeyArray","clientId","sendMessage","sse","lastOutputId","resetupSseConnection","close","lastEventId","dappsState","internalAccountId","clientIds","extractKey","EventSource","openEventSource","onmessage","encryptedMessage","sseDapp","fullBuffer","nonce","subarray","decrypted","jsonText","decryptMessage","setSseLastEventId","sendSseDisconnect","toId","topic","randomBytes","encryptMessage","sendRawMessage","swapEstimate","swapBuild","swapGetCurrencies","swapGetTonCurrencies","swapGetTonPairs","initLegacyDappMethods","accounts","requestAccounts","getBalance","requestWallets","dataType","processedData","processedStateInit","payloadBoc","signedMessage","sendLedgerTransaction","connectUpdater","legacyDappMethods","dappMethods","idbStorage","idbData","getAll","setMany","field","raw","oldItem","newItem","prevValue","newValue","rawData","accountDapps","migrateStorage","ALLOWED_METHODS","Set","dappApi","legacyDappApi","has","startsWith","tonConnectApi","byKey","member","newByKey","object","stringKeys","areSortedArraysEqual","array1","array2","every","start","end","fromKeyValueArrays","isArray","_len2","_key2","log","ms","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","m","O","chunkIds","priority","notFulfilled","Infinity","fulfilled","j","r","getter","__esModule","d","definition","o","defineProperty","enumerable","g","globalThis","Function","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","chunkLoadingGlobal","__webpack_exports__"],"sourceRoot":""}